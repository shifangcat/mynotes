import{_ as n}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as a,c as s,f as e}from"./app-VKLC1A-x.js";const i={},t=e(`<h1 id="关联机制-hint-提示-高水位线" tabindex="-1"><a class="header-anchor" href="#关联机制-hint-提示-高水位线" aria-hidden="true">#</a> 关联机制_HINT 提示_高水位线</h1><h2 id="关联机制" tabindex="-1"><a class="header-anchor" href="#关联机制" aria-hidden="true">#</a> 关联机制</h2><h3 id="关联机制分类" tabindex="-1"><a class="header-anchor" href="#关联机制分类" aria-hidden="true">#</a> 关联机制分类</h3><ul><li><p><strong>嵌套循环关联（NESTED LOOPS JOIN（NL））</strong></p><p>适用于一张大表和一张小表的关联，小表作为驱动表，大表作为被被驱动表</p></li><li><p><strong>哈希关联（Hash Join（HJ））</strong></p><p>适用于两张大表的关联，并且还是等值关联，在做关联的时候，会先对关联字段中的数据做哈希值的计算，计算完了再拿哈希值做匹配</p></li><li><p><strong>排序合并连接（Sort Merge Join（SMJ））</strong></p><p>先对关联字段的数据做一个排序，再拿排好顺序的数据做关联，适合有索引的两张表或者不等关联</p></li></ul><h3 id="查看执行计划" tabindex="-1"><a class="header-anchor" href="#查看执行计划" aria-hidden="true">#</a> 查看执行计划</h3><h4 id="方法一" tabindex="-1"><a class="header-anchor" href="#方法一" aria-hidden="true">#</a> 方法一</h4><p>选中代码，按 F5</p><h4 id="方法二" tabindex="-1"><a class="header-anchor" href="#方法二" aria-hidden="true">#</a> 方法二</h4><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">EXPLAIN</span> <span class="token keyword">PLAN</span> <span class="token keyword">FOR</span> 
<span class="token keyword">SELECT</span> <span class="token operator">*</span> 
<span class="token keyword">FROM</span> STUDENT T1
<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> SC T2 
       <span class="token keyword">ON</span> T1<span class="token punctuation">.</span>SNO <span class="token operator">=</span> T2<span class="token punctuation">.</span>SNO<span class="token punctuation">;</span>

<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token keyword">TABLE</span><span class="token punctuation">(</span>DBMS_XPLAN<span class="token punctuation">.</span>DISPLAY<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="hint-提示" tabindex="-1"><a class="header-anchor" href="#hint-提示" aria-hidden="true">#</a> HINT 提示</h2><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">-- 常用的 HINT 提示及作用</span>
<span class="token comment">/*+ PARALLEL(表名1,并行数)[(表名2,并行数)……] */</span>  <span class="token comment">-- 指定开启多少个并行|并发（一般为2、4、8 ...）</span>
<span class="token comment">/*+ INDEX(表名,索引名) */</span>  <span class="token comment">-- 指定索引扫描</span>
<span class="token comment">/*+ FULL(表名) */</span>  <span class="token comment">-- 指定全表扫描</span>
<span class="token comment">/*+ USE_NL(表名1，表名2) */</span>  <span class="token comment">-- 指定用 NESTED LOOPS 关联机制</span>
<span class="token comment">/*+ USE_HASH(表名1，表名2) */</span>  <span class="token comment">-- 指定用 HASH 关联机制</span>
<span class="token comment">/*+ USE_MERGE(表名1，表名2) */</span>  <span class="token comment">-- 指定用 SORT MERGE 关联机制</span>
<span class="token comment">/*+ LEADING(表名1，表名2) */</span>  <span class="token comment">-- 指定表 1 作为驱动表</span>
<span class="token comment">/*+ APPEND */</span> <span class="token comment">-- 数据直接插入到高水位上面（与 INSERT 连用），无视前面的空位置</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="高水位线" tabindex="-1"><a class="header-anchor" href="#高水位线" aria-hidden="true">#</a> 高水位线</h2><p>高水位线插入即在插入数据的时候使用了 <code>/*+ APPEND */</code> 提示，可能会导致碎片问题。在插入数据的时候，会将数据往高水位线之后插入，性能得到了提高；但是在查询数据的时候，高水位线之前空着的那些存储单元也要去检索，所以在查询数据的时候性能降低了</p><p>插入数据的时候性能得到了提升，查询数据的时候比较慢，可能就是高水位线导致的</p><h3 id="解决高水位线碎片问题的方法" tabindex="-1"><a class="header-anchor" href="#解决高水位线碎片问题的方法" aria-hidden="true">#</a> 解决高水位线碎片问题的方法</h3><p>先备份数据，再用 <code>TRUNCATE TABLE</code> 的方法清除数据，再将数据从备份中导入原表</p>`,16),c=[t];function o(d,l){return a(),s("div",null,c)}const h=n(i,[["render",o],["__file","18_关联机制_HINT提示_高水位线.html.vue"]]);export{h as default};
