import{_ as n}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as s,c as a,f as e}from"./app-VKLC1A-x.js";const t="/mynotes/assets/ORM实现图解-LIKgZtzp.png",p={},o=e(`<h1 id="mini-web框架" tabindex="-1"><a class="header-anchor" href="#mini-web框架" aria-hidden="true">#</a> mini-web框架</h1><h2 id="wsgi" tabindex="-1"><a class="header-anchor" href="#wsgi" aria-hidden="true">#</a> WSGI</h2><p>WSGI允许开发者将选择web框架和web服务器分开。可以混合匹配web服务器和web框架，选择一个适合的配对</p><p>web服务器必须具备WSGI接口，所有的现代Python Web框架都已具备WSGI接口，它让你不对代码作修改就能使服务器和特点的web框架协同工作</p><p><strong>定义WSGI接口</strong>：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">application</span><span class="token punctuation">(</span>environ<span class="token punctuation">,</span> start_response<span class="token punctuation">)</span><span class="token punctuation">:</span>
    start_response<span class="token punctuation">(</span><span class="token string">&#39;200 OK&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">&#39;Content-Type&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;text/html&#39;</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">return</span> <span class="token string">&#39;Hello World!&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>上面的函数就是符合WSGI标准的一个HTTP处理函数，它接收两个参数：</p><p><code>environ</code>：一个包含所有HTTP请求信息的dict对象</p><p><code>start_response</code>：一个发送HTTP响应的函数</p></blockquote><h2 id="闭包" tabindex="-1"><a class="header-anchor" href="#闭包" aria-hidden="true">#</a> 闭包</h2><p><strong>定义</strong>：在函数内部再定义一个函数，并且这个函数用到了外边函数的变量，那么将这个函数以及用到的一些变量称之为闭包</p><p>在闭包的函数里面修改其外部函数中的变量，使用<code>nonlocal</code></p><p><strong>思考</strong>：函数、匿名函数、闭包、对象，当做实参时，有什么区别？</p><p><em><strong>1&gt;</strong></em> 匿名函数能够完成基本的简单功能，传递的是这个函数的引用，只有功能</p><p><em><strong>2&gt;</strong></em> 普通函数能够完成较为复杂的功能，传递的是这个函数的引用，只有功能</p><p><em><strong>3&gt;</strong></em> 闭包能够将较为复杂的功能，传递的是这个闭包中的函数以及数据，因此传递是功能+数据</p><p><em><strong>4&gt;</strong></em> 对象能够完成最为复杂的功能，传递的是很多数据+很多功能，因此传递的是功能+数据</p><h2 id="装饰器" tabindex="-1"><a class="header-anchor" href="#装饰器" aria-hidden="true">#</a> 装饰器</h2><p>装饰器是一个包含闭包的函数</p><p>通过在新定义的函数前一行添加<code>@函数名</code>的方式，可以用被@的函数对新定义的函数进行装饰</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">set_func</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">call_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&#39;---权限验证---&#39;</span><span class="token punctuation">)</span>
        func<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> call_func

<span class="token decorator annotation punctuation">@set_func</span>  <span class="token comment"># 等价于 test = set_func(test)</span>
<span class="token keyword">def</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&#39;---test---&#39;</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><em><strong>1&gt;</strong></em> 在新定义的函数前面遇到@函数名的时候就已经对新定义的函数装饰完成了，此时新定义的函数的函数名将指向被@的函数中的闭包函数，同时闭包函数中从外部函数获取到的变量也已经指向了新定义的函数；此时再执行新定义的函数时，将会是执行闭包函数，在执行过程中遇到其从外部函数获取到的变量时，会跳转到新定义的函数处进行执行（因为此时从外部函数获取到的变量已经是指向了新定义的函数）</p><p><em><strong>2&gt;</strong></em> 装饰器在调用函数之前已经被Python解释器执行了，所以要牢记，当调用函数之前，其实已经装饰好了，尽管调用就可以了</p><p><em><strong>3&gt;</strong></em> 装饰器可以对多个函数进行装饰</p><p><strong>通用装饰器</strong>：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">set_func</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">call_func</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&#39;---权限验证---&#39;</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>
    <span class="token keyword">return</span> call_func
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><em><strong>1&gt;</strong></em> 多个装饰器对同一个函数进行装饰时，由定义函数位置开始，从下向上装饰，运行时，从上向下运行</p><p><em><strong>2&gt;</strong></em> 带有参数的装饰器</p><p><em><strong>3&gt;</strong></em> 通过带有参数的装饰器实现路由</p><h2 id="伪静态、静态和动态" tabindex="-1"><a class="header-anchor" href="#伪静态、静态和动态" aria-hidden="true">#</a> 伪静态、静态和动态</h2><h3 id="静态url" tabindex="-1"><a class="header-anchor" href="#静态url" aria-hidden="true">#</a> 静态URL</h3><p><strong>定义</strong>：静态URL类似域名<code>/news/2012-5-18/110.html</code>，每个网页有真实的物理路径，也就是真实存在服务器里</p><p><strong>优点</strong>：网站打开速度快，不用进行运算；另外网址结构比较友好，利于记忆</p><p><strong>缺点</strong>：中大型网站，则产生的页面特别多，不好管理，占用硬盘空间</p><p><strong>总结</strong>：静态网站对SEO的影响：静态URL打开速度快，有利于增加SEO得分</p><h3 id="动态url" tabindex="-1"><a class="header-anchor" href="#动态url" aria-hidden="true">#</a> 动态URL</h3><p><strong>定义</strong>：动态URL类似域名<code>/NewsMore.asp?id=5</code>或者域名<code>/DaiKuan.php?id=17</code>，带有<code>?</code>号的URL，每个URL只是一个逻辑地址，并不是真实存在服务器硬盘里的</p><p><strong>优点</strong>：适合中大型网站，修改页面很方便；占用硬盘空间要比纯静态网站小</p><p><strong>缺点</strong>：因为要进行运算，所以打开速度稍慢；URL结构复杂，不利于记忆</p><p><strong>总结</strong>：动态URL对SEO的影响：打开速度稍慢，略有影响</p><h3 id="伪静态url" tabindex="-1"><a class="header-anchor" href="#伪静态url" aria-hidden="true">#</a> 伪静态URL</h3><p><strong>定义</strong>：伪静态URL类似域名<code>/course/74.html</code>，和真静态URL类似。通过伪静态规则把动态URL伪装成静态网址</p><p><strong>优点</strong>：URL比较友好，利于记忆；逻辑地址，不存在物理地址</p><p><strong>缺点</strong>：设置麻烦，服务器要支持重写规则；进行运算解释，增加服务器负担</p><h2 id="url编解码" tabindex="-1"><a class="header-anchor" href="#url编解码" aria-hidden="true">#</a> URL编解码</h2><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">import</span> urllib<span class="token punctuation">.</span>parse
a <span class="token operator">=</span> <span class="token string">&#39;这是字符串&#39;</span>
b <span class="token operator">=</span> urllib<span class="token punctuation">.</span>parse<span class="token punctuation">.</span>quote<span class="token punctuation">(</span>a<span class="token punctuation">)</span>    <span class="token comment"># 编码</span>
c <span class="token operator">=</span> urllib<span class="token punctuation">.</span>parse<span class="token punctuation">.</span>unquote<span class="token punctuation">(</span>b<span class="token punctuation">)</span>  <span class="token comment"># 解码</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="log日志" tabindex="-1"><a class="header-anchor" href="#log日志" aria-hidden="true">#</a> log日志</h2><h3 id="日志级别" tabindex="-1"><a class="header-anchor" href="#日志级别" aria-hidden="true">#</a> 日志级别</h3><p>日志一共分成5个等级，从低到高分别是：</p><p><strong>DEBUG</strong>：详细的信息，通常只出现在诊断问题上</p><p><strong>INFO</strong>：确认一切按预期运行</p><p><strong>WARNING</strong>：一个迹象表明，一些意想不到的事情发生了，或表明一些问题在不久的将来（例如：磁盘空间低&quot;），这个软件还能按预期工作</p><p><strong>ERROR</strong>：更严重的问题，软件没能执行一些功能</p><p><strong>CRITICAL</strong>：一个严重的错误，这表明程序本身可能无法继续运行</p><h3 id="获取日志" tabindex="-1"><a class="header-anchor" href="#获取日志" aria-hidden="true">#</a> 获取日志</h3><p><em><strong>1&gt;</strong></em> <code>logging.basicConfig()</code></p><blockquote><p>参数：</p><p><code>level=</code>：修改监测级别，默认是WARNING</p><p><code>filename=str</code>：输出到文件的文件名，不写默认输出到控制台</p><p><code>filemode=str</code>：文件的写入方式</p><p><code>format=str</code>：调整日志的输出格式</p></blockquote><p><em><strong>2&gt;</strong></em> <code>logging.debug/info/warning/error/critical</code></p><h3 id="日志输出" tabindex="-1"><a class="header-anchor" href="#日志输出" aria-hidden="true">#</a> 日志输出</h3><p><em><strong>1&gt;</strong></em> 将日志输出到控制台</p><p><em><strong>2&gt;</strong></em> 将日志输出到文件</p><p><em><strong>3&gt;</strong></em> 既要把日志输出到控制台，还要写入日志文件</p><h3 id="日志格式说明" tabindex="-1"><a class="header-anchor" href="#日志格式说明" aria-hidden="true">#</a> 日志格式说明</h3><p><code>logging.basicConfig</code>函数中，可以指定日志的输出格式format，这个参数可以输出很多有用的信息，如下：</p><p><code>%(levelno)s</code>：打印日志级别的数值</p><p><code>%(levelname)s</code>：打印日志级别名称</p><p><code>%(pathname)s</code>：打印当前执行程序的路径，其实就是<code>sys.argv[0]</code></p><p><code>%(filename)s</code>：打印当前执行程序名</p><p><code>%(funcName)s</code>：打印日志的当前函数</p><p><code>%(lineno)d</code>：打印日志的当前行号</p><p><code>%(asctime)s</code>：打印日志的时间</p><p><code>%(thread)d</code>：打印线程ID</p><p><code>%(threadName)s</code>：打印线程名称</p><p><code>%(process)d</code>：打印进程ID</p><p><code>%(message)s</code>：打印日志信息</p><p><strong>在工作中给的常用格式如下</strong>：</p><p><code>format=&#39;%(asctime)s - %(filename)s[line: %(lineno)d] - %(levelname)s: %(message)s&#39;</code></p><blockquote><p>这个格式可以输出日志的打印时间，是哪个模块输出的，输出的日志级别是什么，以及输入的日志内容</p></blockquote><h2 id="元类" tabindex="-1"><a class="header-anchor" href="#元类" aria-hidden="true">#</a> 元类</h2><p>类创建实例对象</p><p>元类创建类</p><p>元类也是由元类创建的</p><p><strong>使用type创建类</strong>：</p><p><code>type(类名, 由父类名称组成的元组(针对继承的情况，可以为空), 包含属性的字典{key和value})</code></p><p>元类的主要目的就是为了当创建类时能够自动地改变类</p><p>metaclass的应用：当代码执行到class时，Python会检索这个类和其父类中是否有metaclass，如果有，则使用其提供的方式创建类，没有则使用内置的type来创建</p><p><strong>元类的目的</strong>：</p><p>拦截类的创建</p><p>自主地创建类</p><p>返回自主创建之后的类</p><h2 id="orm-对象关系映射" tabindex="-1"><a class="header-anchor" href="#orm-对象关系映射" aria-hidden="true">#</a> ORM（对象关系映射）</h2><p><strong>定义</strong>：ORM是python编程语言后端web框架Django的核心思想，“Object Relational Mapping”，即对象-关系映射，简称ORM</p><p>一句话理解就是：创建一个实例对象，用创建它的类名当做数据表名，用创建它的类属性对应数据表的字段，当对这个实例对象操作时，能够执行对应的MySQL语句</p><figure><img src="`+t+'" alt="ORM实现图解" tabindex="0" loading="lazy"><figcaption>ORM实现图解</figcaption></figure>',92),c=[o];function r(i,d){return s(),a("div",null,c)}const g=n(p,[["render",r],["__file","04_mini-web框架.html.vue"]]);export{g as default};
