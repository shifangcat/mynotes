import{_ as t}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as e,c as l,f as r}from"./app-VKLC1A-x.js";const p={},o=r('<h1 id="web服务器" tabindex="-1"><a class="header-anchor" href="#web服务器" aria-hidden="true">#</a> Web服务器</h1><h2 id="http协议" tabindex="-1"><a class="header-anchor" href="#http协议" aria-hidden="true">#</a> HTTP协议</h2><p><strong>http协议</strong>：超文本传输协议</p><p>在web应用中，服务器把网页的HTML代码发送给浏览器，让浏览器显示出来。浏览器和服务器之间的传输协议就是HTTP，所以：</p><p><em><strong>1&gt;</strong></em> HTML是一种用来定义网页的文本，会HTML，就可以编写网页</p><p><em><strong>2&gt;</strong></em> HTTP是在网络上传输HTML的协议，用于浏览器和服务器的通信</p><h2 id="web静态服务器" tabindex="-1"><a class="header-anchor" href="#web静态服务器" aria-hidden="true">#</a> Web静态服务器</h2><p>按需返回页面</p><p>多进程按需返回页面</p><p>多线程按需返回页面</p><p>协程gevent按需返回页面</p><p>单进程/单线程/非堵塞实现多任务：</p><p><code>tcp_socket.setblocking(False)</code>：将套接字设置为非堵塞模式</p><h3 id="tcp长连接和短连接" tabindex="-1"><a class="header-anchor" href="#tcp长连接和短连接" aria-hidden="true">#</a> TCP长连接和短连接</h3><p>TCP在真正的读写操作之前，server和client之间必须三次握手建立一个连接，当读写操作完成后，双方不再需要这个连接时，它们会通过四次挥手释放这个连接。所以每次连接的建立都需要消耗时间和资源</p><ul><li><p>短连接一般只会在client和server之间传递一次读写操作</p><p>建立连接 -&gt; 数据传输 -&gt; 关闭连接 ... 建立连接 -&gt; 数据传输 -&gt; 关闭连接</p></li><li><p>长连接在一次读写操作完成后不会立刻关闭，多次读写后，client才会发起关闭请求</p><p>建立连接 -&gt; 数据传输 ...（保持连接）... 数据传输 -&gt; 关闭连接</p></li></ul><p><em><strong>注</strong></em>：HTTP协议1.0规定的是短连接，1.1是长连接</p><h3 id="epoll" tabindex="-1"><a class="header-anchor" href="#epoll" aria-hidden="true">#</a> epoll</h3><ul><li><p><strong>IO多路复用</strong>：</p><ul><li><p>就是我们说的select、poll、epoll，有些地方也称这种IO方式为event driven IO</p></li><li><p>select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO，基本原理就是select、poll、epoll这个function会不断地轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程</p></li></ul></li><li><p><strong>创建</strong>：<code>epl = select.epoll()</code></p></li><li><p><strong>使用</strong>： <code>epl.register(fd[, eventmask])</code>：注册事件到epoll中</p><blockquote><p>fd可通过 对象.fileno()获取，</p><p>select.EPOLLIN ：进行事件监测</p></blockquote><p><code>fd_event_list = epl.poll()</code>：默认会堵塞，直到os监测到数据到来通过事件通知的方式，告诉程序，此时才会解堵塞；fd_event_list列表中存储的是套接字对应的文件描述符和其对应的事件组成的元组 [(fd1, event1), (fd2, event2)]</p><p><code>epl.unregister(fd)</code>：从epoll中取消注册</p></li></ul><p><em><strong>注</strong></em>：epoll在Linux系统中才能运行</p><h2 id="网络通信" tabindex="-1"><a class="header-anchor" href="#网络通信" aria-hidden="true">#</a> 网络通信</h2><p><strong>IP地址</strong>：在逻辑上标记一台电脑，用来指引数据包的收发方向（相当于电脑的序列号）</p><p><strong>网络掩码</strong>：用来区分ip地址的网络号和主机号</p><p><strong>MAC地址</strong>：在设备与设备之间数据通信时用来标记收发双方（网卡的序列号）</p><p><strong>默认网关</strong>：当需要发送的数据包的目的ip不在本网段内时，就会发送给默认的一台电脑，成为网关</p><p><strong>集线器</strong>：已过时，用来连接多态电脑，缺点：每次收发数据都进行广播，网络会变的拥堵</p><p><strong>交换机</strong>：集线器的升级版，有学习功能知道需要发送给哪台设备，根据需要进行单播、广播</p><p><strong>路由器</strong>：连接多个不同的网段，让他们之间可以进行收发数据，每次收到数据后，IP不变，但是MAC地址会变化</p><p><strong>DNS</strong>：用来解析出IP（类似电话簿）</p><p><strong>HTTP服务器</strong>：提供浏览器能够访问到的数据</p><p><strong>TCP/IP协议（族）</strong>：因为互联网协议包含了上百种协议标准，但是最重要的两个协议是TCP和IP协议，所以大家把互联网的协议简称TCP/IP协议族</p><table><thead><tr><th style="text-align:left;"><strong>TCP/IP</strong></th><th style="text-align:left;"><strong>OSI</strong></th></tr></thead><tbody><tr><td style="text-align:left;">应用层</td><td style="text-align:left;">应用层<br>表示层<br>会话层</td></tr><tr><td style="text-align:left;">运输层</td><td style="text-align:left;">传输层</td></tr><tr><td style="text-align:left;">网际层（又称网络层）</td><td style="text-align:left;">网络层</td></tr><tr><td style="text-align:left;">网络接口层（又称链路层）</td><td style="text-align:left;">数据链路层</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">物理层</td></tr></tbody></table>',32),n=[o];function s(d,a){return e(),l("div",null,n)}const c=t(p,[["render",s],["__file","03_Web服务器.html.vue"]]);export{c as default};
