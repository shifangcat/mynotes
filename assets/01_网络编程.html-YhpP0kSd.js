import{_ as t}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as e,c as a,f as l}from"./app-VKLC1A-x.js";const n={},p=l(`<h1 id="网络编程" tabindex="-1"><a class="header-anchor" href="#网络编程" aria-hidden="true">#</a> 网络编程</h1><h2 id="ip地址的分类" tabindex="-1"><a class="header-anchor" href="#ip地址的分类" aria-hidden="true">#</a> IP地址的分类</h2><h3 id="ipv4" tabindex="-1"><a class="header-anchor" href="#ipv4" aria-hidden="true">#</a> IPv4</h3><p>四组数字组成，用“.”隔开，每组范围从0-255，共有256<em>256</em>256*256种</p><ul><li><p>每一个IP地址包括两部分，网络地址（网络号）和主机地址（主机号）</p></li><li><p>每组数字中最小的0和最大的255不能使用</p></li></ul><h3 id="ipv6和私有ip" tabindex="-1"><a class="header-anchor" href="#ipv6和私有ip" aria-hidden="true">#</a> IPv6和私有IP</h3><p>国际规定有一部分ip地址是用于局域网使用，也就是属于私网ip，不在公网中使用的，它们的范围是：</p><p>10.0.0.0~10.255.255.255</p><p>172.16.0.0~172.31.255.255</p><p>192.168.0.0~192.168.255.255</p><h2 id="端口" tabindex="-1"><a class="header-anchor" href="#端口" aria-hidden="true">#</a> 端口</h2><p>端口相当于进入程序的门，如果一个程序需要收发网络数据，就需要有端口</p><p>在linux系统中，端口可以有65536（2的16次方）个之多</p><p>为了方便对如此多的端口进行统一管理，于是进行了编号，这就是端口号</p><h3 id="端口号" tabindex="-1"><a class="header-anchor" href="#端口号" aria-hidden="true">#</a> 端口号</h3><p>端口是通过端口号来标记的，端口号只有整数，范围是从0到65535</p><h3 id="端口的分配" tabindex="-1"><a class="header-anchor" href="#端口的分配" aria-hidden="true">#</a> 端口的分配</h3><p>端口按照一定的规定进行分配</p><p>端口的分类标准有好几种</p><ul><li><p>知名端口：众所周知的端口号，范围从0到1023</p></li><li><p>80端口分配给HTTP服务</p><ul><li><p>21端口分配给FTP服务</p></li><li><p>一般情况下，如果一个程序需要使用知名端口需要有root权限</p></li></ul></li><li><p>动态端口：范围是从1024到65535</p><p>动态端口一般不固定分配某种服务，而是动态分配，即：当一个系统程序或应用程序需要网络通信时，它向主机申请一个端口，主机从可用的端口号中分配一个供它使用，当程序关闭时，同时也将释放出它所占用的端口号</p></li><li><p>查看端口：</p><p>用“netstat-an”查看端口状态</p><p>lsof-i[tcp/udp]:2425</p></li></ul><h2 id="socket" tabindex="-1"><a class="header-anchor" href="#socket" aria-hidden="true">#</a> socket</h2><p>socket（简称套接字）是进程间通信的一种方式，它与其他进程间通信的一个主要不同是：它能实现不同主机间的进程通信，我们网络上各种各样的服务大多都是基于socket来完成通信的</p><h3 id="创建socket" tabindex="-1"><a class="header-anchor" href="#创建socket" aria-hidden="true">#</a> 创建socket</h3><p>在python中使用socket模块的函数socket就可以完成：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">import</span> socket
socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>AddressFamily<span class="token punctuation">,</span>Type<span class="token punctuation">)</span>
<span class="token comment"># AddressFamily：可以选择AF_INET（用于Internet进程间通信）或者AF_UNIX（用于同一台机器进程间通信），实际工作中常用AF_INET</span>
<span class="token comment"># Type：套接字类型，可以是SOCK_STREAM（流式套接字，主要用于TCP协议）或者SOCK_DGRAM（数据报套接字，主要用于UDP协议）</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>发送数据的流程：</p><p><em><strong>1&gt;</strong></em> 创建套接字</p><p><em><strong>2&gt;</strong></em> 发送数据</p><p><em><strong>3&gt;</strong></em> 关闭</p></li><li><p>接收数据的流程：</p><p><em><strong>1&gt;</strong></em> 创建套接字</p><p><em><strong>2&gt;</strong></em> 绑定本地信息</p><p><em><strong>3&gt;</strong></em> 接收数据</p><p><em><strong>4&gt;</strong></em> 关闭</p></li></ul><h3 id="单工、半双工、全双工" tabindex="-1"><a class="header-anchor" href="#单工、半双工、全双工" aria-hidden="true">#</a> 单工、半双工、全双工</h3><p>单工：只能收或只能发，如：收音机</p><p>半双工：收和发都可以，但同时只能做一个，如：对讲机</p><p>全双工：可以同时收发，如：手机，socket</p><h2 id="udp和tcp" tabindex="-1"><a class="header-anchor" href="#udp和tcp" aria-hidden="true">#</a> UDP和TCP</h2><h3 id="udp介绍" tabindex="-1"><a class="header-anchor" href="#udp介绍" aria-hidden="true">#</a> UDP介绍</h3><p>通信前不需要建立相关的链接，只需要发送数据即可</p><h3 id="tcp介绍" tabindex="-1"><a class="header-anchor" href="#tcp介绍" aria-hidden="true">#</a> TCP介绍</h3><p>TCP协议，传输控制协议，是一种面向连接的、可靠的、基于字节流的传输层通信协议</p><p>TCP通信需要经过创建连接、数据传送、终止连接三个步骤</p><p>TCP特点：</p><ul><li><p>面向连接：</p><p>通信双方必须先建立连接才能进行数据传输，双方都必须为该连接分配必要的系统内核资源，以管理连接的状态和连接上的传输。完成数据交换后，双方必须断开此连接，以释放系统资源</p></li><li><p>可靠传输：</p><ul><li><p>TCP采用发送应答机制：</p><p>TCP发送的每个报文段都必须得到接收方的应答才认为这个TCP报文段传输成功</p></li><li><p>超时重传：</p><p>发送端发出一个报文段之后就启动定时器，如果在定时时间内没有收到应答就重新发送这个报文段</p></li><li><p>错误校验：</p><p>TCP用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和，如果有误，则自 动重新发送</p></li><li><p>流量控制和阻塞管理：</p><p>流量控制用来避免主机发送得过快而使接收方来不及完全收下</p></li></ul></li></ul><h3 id="udp、tcp客户端、tcp服务器使用流程比较" tabindex="-1"><a class="header-anchor" href="#udp、tcp客户端、tcp服务器使用流程比较" aria-hidden="true">#</a> UDP、TCP客户端、TCP服务器使用流程比较</h3><table><thead><tr><th style="text-align:left;"><strong>UDP</strong></th><th style="text-align:left;"><strong>TCP客户端</strong></th><th style="text-align:left;"><strong>TCP服务器</strong></th></tr></thead><tbody><tr><td style="text-align:left;">socket</td><td style="text-align:left;">socket</td><td style="text-align:left;">socket</td></tr><tr><td style="text-align:left;">bind()（按需绑定）</td><td style="text-align:left;">connect()</td><td style="text-align:left;">bind()</td></tr><tr><td style="text-align:left;">sendto()/recvfrom()</td><td style="text-align:left;">send()/recv()</td><td style="text-align:left;">listen()</td></tr><tr><td style="text-align:left;">close()</td><td style="text-align:left;">close()</td><td style="text-align:left;">accept()</td></tr><tr><td style="text-align:left;">/</td><td style="text-align:left;">/</td><td style="text-align:left;">recv()/send()</td></tr><tr><td style="text-align:left;">/</td><td style="text-align:left;">/</td><td style="text-align:left;">close()</td></tr></tbody></table>`,40),i=[p];function s(d,r){return e(),a("div",null,i)}const o=t(n,[["render",s],["__file","01_网络编程.html.vue"]]);export{o as default};
