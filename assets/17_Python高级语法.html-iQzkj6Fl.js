import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o,c as d,f as c}from"./app-VKLC1A-x.js";const p={},r=c(`<h1 id="python高级语法" tabindex="-1"><a class="header-anchor" href="#python高级语法" aria-hidden="true">#</a> Python高级语法</h1><h2 id="gil-全局解释器锁" tabindex="-1"><a class="header-anchor" href="#gil-全局解释器锁" aria-hidden="true">#</a> GIL（全局解释器锁）</h2><p>GIL指使用Cpython解释器时，即便是多线程的程序，在同一时间也只能有一个线程在运行</p><p><strong>解决方法</strong>：使用其它语言，或者更换其他语言的解释器</p><p>计算密集型：使用进程</p><p>io密集型：使用线程、协程</p><h2 id="深拷贝、浅拷贝" tabindex="-1"><a class="header-anchor" href="#深拷贝、浅拷贝" aria-hidden="true">#</a> 深拷贝、浅拷贝</h2><p><strong>浅拷贝</strong>：对于一个对象的顶层拷贝。拷贝了引用，并没有拷贝内容</p><p><code>copy.copy()</code>：浅拷贝</p><p><em><strong>注</strong></em>：如果<code>copy.copy()</code>拷贝的是元组，那么它不会进行浅拷贝，仅仅是引用指向，因为元组是不可变类型，意味着数据一定不能修改，因此用<code>copy.copy()</code>的时候它会自动判断，仅仅只会指向元组</p><p><strong>深拷贝</strong>：对一个对象所有层次的拷贝（递归）</p><p><code>copy.deepcopy()</code>：深拷贝</p><p><em><strong>注</strong></em>：如果用<code>copy.copy()</code>、<code>copy.deepcopy()</code>对一个全部都是不可变类型的数据进行拷贝，那么它们的结果相同，都是引用指向。如果拷贝的是一个拥有可变类型的数据，即使元组是最顶层，那么<code>copy.deepcopy()</code>会进行深拷贝，而<code>copy.copy()</code>还是引用指向</p><h2 id="import" tabindex="-1"><a class="header-anchor" href="#import" aria-hidden="true">#</a> import</h2><p><strong>import搜索路径</strong>：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">import</span> sys
sys<span class="token punctuation">.</span>path
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>使用上述方法可以查看模块导入的路径列表，import导入模块时会按照列表中路径的先后顺序搜索，<code>&#39;&#39;</code>表示当前路径</p><p>程序执行时添加新的模块路径：</p><p><code>sys.path.append(&#39;/home/xxx&#39;)</code>：在列表最后添加路径</p><p><code>sys.path.insert(index, &#39;/home/xxx&#39;)</code>：在指定索引位置添加路径</p><p><strong>重新导入模块</strong>：模块被导入后，不能重新导入，要想重新导入，需要使用<code>reload</code></p><h2 id="类的再研究" tabindex="-1"><a class="header-anchor" href="#类的再研究" aria-hidden="true">#</a> 类的再研究</h2><h3 id="类的私有化" tabindex="-1"><a class="header-anchor" href="#类的私有化" aria-hidden="true">#</a> 类的私有化</h3><p><code>xx</code>：公有变量</p><p><code>_xx</code>：单前置下划线，私有化属性或方法，<code>from somemodule import *</code>禁止导入，类对象和子类可以访问</p><p><code>__xx</code>：双前置下划线，避免与子类中的属性命名冲突，无法在外部直接访问（名字重整所以访问不到）</p><p><code>__xx__</code>：双前后下划线，用户名字空间的魔法对象或属性，属于公有的，子类可以继承。例如：<code>__init__</code>。__不要自己发明这样的名字</p><p><code>xx_</code>：单后置下划线，用于避免与Python关键字的冲突</p><h3 id="多继承" tabindex="-1"><a class="header-anchor" href="#多继承" aria-hidden="true">#</a> 多继承</h3><p><strong>多继承的MRO顺序</strong>：</p><p><em><strong>1&gt;</strong></em> <code>父类名.方法()</code>：直接调用该父类的方法，可能导致父类方法被多次调用</p><p><em><strong>2&gt;</strong></em> <code>super().方法()</code>：按照<code>mro</code>顺序寻找后一个类中的方法去执行</p><p><em><strong>3&gt;</strong></em> <code>super(父类名, self).方法()</code>：按照mro顺序寻找该父类后一个类的方法执行</p><p><em><strong>注</strong></em>：</p><p><em><strong>1&gt;</strong></em> 多继承时，使用<code>父类名.方法名</code>调用父类的方法时，只需要传递该父类需要的参数即可；而使用<code>super().方法名</code>调用父类方法时，会按照<code>mro</code>顺序逐个调用，而你无法保证每个父类使用的参数都相同，所以需要全部传参</p><p><em><strong>2&gt;</strong></em> 单继承时，使用<code>super()</code>方法，则不能全部传递，只能传递父类需要的参数，否则会报错</p><h3 id="类对象、实例对象及其属性和方法" tabindex="-1"><a class="header-anchor" href="#类对象、实例对象及其属性和方法" aria-hidden="true">#</a> 类对象、实例对象及其属性和方法</h3><p><em><strong>1&gt;</strong></em> 本质上是类对象、实例对象及其属性和方法在内存中的地址不同</p><p>类属性和实例方法、类方法、静态方法在类对象的内存中存储</p><p>实例属性在实例对象的内存中存储，实例对象有个默认属性<code>__class__</code>，会指向创建它的类</p><p>方法调用时，谁在调用就将谁的引用当做参数传递给方法</p><p><em><strong>2&gt;</strong></em> 实例对象可以访问实例属性和类属性，类对象只能访问类属性</p><p>实例对象可以调用实例方法、类方法、静态方法，类对象只能调用类方法、静态方法</p><h3 id="property属性" tabindex="-1"><a class="header-anchor" href="#property属性" aria-hidden="true">#</a> property属性</h3><p><strong>定义</strong>：一种用起来像是使用实例属性一样的特殊属性，可以对应于某个方法，目的是简化获取数据的流程</p><ul><li><p><strong>装饰器创建property属性</strong>：</p><ul><li><p><code>@property</code></p><p>在实例方法前添加<code>@property</code>装饰器来定义</p><p>该实例方法仅可有一个self参数</p><p>调用<code>实例对象.方法</code>名时自动执行</p></li><li><p><code>@（property定义的）方法名.setter</code></p><p>用来修改</p><p>调用<code>实例对象.方法名=xxx</code>时自动执行</p></li><li><p><code>@（property定义的）方法名.deleter</code></p><p>用来删除</p><p>调用<code>del 实例对象.方法名</code>时自动执行</p></li></ul></li><li><p><strong>类属性创建property属性</strong>：</p><p><code>类属性=property(方法名1,方法名2,方法名3,字符串)</code></p><blockquote><p>第一个参数是方法名1，调用<code>对象.属性</code>时自动触发执行此方法</p><p>第二个参数是方法名2，调用<code>对象.属性=xxx</code>时自动触发执行此方法</p><p>第三个参数是方法名3，调用<code>del 对象.属性</code>时自动触发执行此方法</p><p>第四个参数是字符串，调用<code>类名.属性.__doc__</code>，此参数是该属性的描述信息</p></blockquote></li></ul><h3 id="魔法属性" tabindex="-1"><a class="header-anchor" href="#魔法属性" aria-hidden="true">#</a> 魔法属性</h3><p><code>__doc__</code>：获取类的描述信息</p><p><code>__module__</code>：获取对象所在的模块</p><p><code>__class__</code>：获取对象所属的类</p><p><code>__init__</code>：初始化方法，通过类创建对象时，自动触发执行</p><p><code>__del__</code>：当对象从内存中被释放时，自动触发执行</p><p><code>__call__</code>：对象后面加括号，触发执行</p><p><code>__str__</code>：打印对象时（不带括号），默认输出该方法的返回值</p><p><code>__dict__</code>：获取类或对象中的所有属性</p><p><code>__getitem__</code>、<code>__setitem__</code>、<code>__delitem__</code>：用于索引操作，如字典。分别表示获取、设置、删除数据</p><p><code>__getslice__</code>、<code>__setslice__</code>、<code>__delslice__</code>：这三个方法用于分片操作，如：列表</p><h2 id="上下文管理器" tabindex="-1"><a class="header-anchor" href="#上下文管理器" aria-hidden="true">#</a> 上下文管理器</h2><p><strong>定义</strong>：任何实现了<code>__enter__()</code>和<code>__exit__()</code>方法的对象都可称之为上下文管理器，<code>__enter__()</code>方法打开并返回资源对象，就是你将要打开的那个文件对象，<code>__exit__()</code>方法处理一些清除工作</p><p>上下文管理器对象可以使用<code>with</code>关键字，无需主动地调用<code>close()</code>方法，由系统自动去调用，哪怕中间遇到异常，<code>close()</code>方法也会被调用</p><p>Python还提供了一个<code>contextmanager</code>的装饰器，更进一步简化了上下文管理器的实现方式。通过<code>yield</code>将函数分割成两部分，<code>yield</code>之前的语句在<code>__enter__()</code>方法中执行，<code>yield</code>之后的语句在<code>__exit__()</code>方法中执行。紧跟在<code>yield</code>后面的值是函数的返回值</p><p>Python提供了<code>with</code>语法用于简化资源操作的后续清除操作，是<code>try/finally</code>的替代方法，实现原理建立在上下文管理器之上</p>`,62),t=[r];function a(n,s){return o(),d("div",null,t)}const h=e(p,[["render",a],["__file","17_Python高级语法.html.vue"]]);export{h as default};
