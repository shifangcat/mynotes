import{_ as n}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as a,c as s,f as e}from"./app-VKLC1A-x.js";const t={},p=e(`<h1 id="多任务" tabindex="-1"><a class="header-anchor" href="#多任务" aria-hidden="true">#</a> 多任务</h1><p>多任务就是操作系统可以同时运行多个任务</p><p><strong>并行</strong>：任务数少于CPU核心数</p><p><strong>并发</strong>：任务数多于CPU核心数，时间片轮转</p><h2 id="线程" tabindex="-1"><a class="header-anchor" href="#线程" aria-hidden="true">#</a> 线程</h2><h3 id="语法结构" tabindex="-1"><a class="header-anchor" href="#语法结构" aria-hidden="true">#</a> 语法结构</h3><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code>t <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>函数名<span class="token punctuation">)</span>
t<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>当调用Thread的时候不会创建线程，只有Thread创建出来的实例对象（t）调用<code>start()</code>方法的时候，才会创建子线程以及让这个子线程开始运行</p><p>线程的执行顺序不确定，没有规律</p><p>主线程会等待所有子线程运行结束后才会结束</p><p>查看正在运行的线程的数量：<code>threading.enumerate()</code>，返回一个列表，使用<code>len()</code>查看数量</p></blockquote><h3 id="通过继承thread类创建线程" tabindex="-1"><a class="header-anchor" href="#通过继承thread类创建线程" aria-hidden="true">#</a> 通过继承Thread类创建线程</h3><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code>t <span class="token operator">=</span> 类名<span class="token punctuation">(</span><span class="token punctuation">)</span>
t<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 调用start()方法时，会自动调用类里面的run()方法</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><em><strong>注</strong></em>：这个类一定要继承自<code>threading.Thread</code>类，并且一定要有<code>run()</code>方法</p><h3 id="共享全局变量的问题" tabindex="-1"><a class="header-anchor" href="#共享全局变量的问题" aria-hidden="true">#</a> 共享全局变量的问题</h3><p>共享全局变量的问题：资源竞争</p><p>解决方法：线程同步，协同步调，按预定的先后次序运行</p><ul><li><p><strong>互斥锁</strong>：锁定/非锁定</p><ul><li><p>当多个线程几乎同时修改某一个共享数据的时候，需要进行同步控制</p></li><li><p>某个线程要更改共享数据时，先将其锁定，此时资源的状态为“锁定”，其他线程不能更改，直到该线程释放资源，将资源的状态变成“非锁定”，其他线程才能再次锁定该资源。互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据和正确性。</p></li><li><p><em><strong>创建互斥锁</strong></em>：<code>mutex = threading.Lock()</code>，默认是没有上锁的</p></li><li><p><em><strong>使用互斥锁</strong></em>：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code>mutex<span class="token punctuation">.</span>acquire<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 上锁</span>
mutex<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 解锁</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><em><strong>上锁原则</strong></em>：尽量给最少的代码上锁</p></li></ul></li><li><p><strong>死锁</strong>：</p><ul><li><p>在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁</p></li><li><p>避免死锁：添加超时时间；程序设计时尽量避免（银行家算法）</p></li></ul></li></ul><h2 id="进程" tabindex="-1"><a class="header-anchor" href="#进程" aria-hidden="true">#</a> 进程</h2><h3 id="进程介绍" tabindex="-1"><a class="header-anchor" href="#进程介绍" aria-hidden="true">#</a> 进程介绍</h3><p><strong>程序</strong>：是一个静态的</p><p><strong>进程</strong>：一个程序运行起来后，代码+用到的资源，称之为进程，它是操作系统分配资源的基本单元</p><p><strong>进程的状态</strong>：新建、就绪、运行、等待、死亡</p><p>进程实现多任务会占用更多的资源，因为会进行部分资源拷贝，而不是共享</p><ul><li>创建进程：</li></ul><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code>p<span class="token operator">=</span>multiprocessing<span class="token punctuation">.</span>Process<span class="token punctuation">(</span>target<span class="token operator">=</span>函数名<span class="token punctuation">,</span>args<span class="token operator">=</span><span class="token punctuation">(</span>参数元组<span class="token punctuation">)</span><span class="token punctuation">)</span>
p<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>进程号</strong>：pid；获取：<code>os.getpid()</code></p><h3 id="进程间的通信-queue" tabindex="-1"><a class="header-anchor" href="#进程间的通信-queue" aria-hidden="true">#</a> 进程间的通信：Queue</h3><p>队列Quene的创建和使用：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token comment"># 创建Quene：</span>
q<span class="token operator">=</span>multiprocessing<span class="token punctuation">.</span>Queue<span class="token punctuation">(</span>num<span class="token punctuation">)</span>  <span class="token comment"># num为最大接收数量，不写或为负表示不限数量</span>

<span class="token comment"># Quene的使用：</span>
q<span class="token punctuation">.</span>put<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># 放入队列</span>
q<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># 从队列中取出</span>
q<span class="token punctuation">.</span>qsize<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 获取队列中消息的数量</span>
q<span class="token punctuation">.</span>empty<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 判断队列是否为空</span>
q<span class="token punctuation">.</span>full<span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment"># 判断队列是否满了</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="进程池pool" tabindex="-1"><a class="header-anchor" href="#进程池pool" aria-hidden="true">#</a> 进程池Pool</h3><p>进程池Pool的创建和使用</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token comment"># 创建Pool</span>
po <span class="token operator">=</span> multiprocessing<span class="token punctuation">.</span>Pool<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>  <span class="token comment"># 最大进程数为3</span>
po<span class="token punctuation">.</span>apply_async<span class="token punctuation">(</span>要调用的目标函数<span class="token punctuation">,</span> <span class="token punctuation">(</span>传递给目标的参数元组<span class="token punctuation">)</span><span class="token punctuation">)</span>
po<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 关闭进程池，关闭后po不再接收新的请求</span>
po<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment"># 等待po中所有子进程执行完成，必须放在close()语句之后</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>进程池通信：需要使用<code>q=multiprocessing.Manager().Queue()</code>创建队列</p></blockquote><h2 id="进程和线程的比较" tabindex="-1"><a class="header-anchor" href="#进程和线程的比较" aria-hidden="true">#</a> 进程和线程的比较</h2><ul><li><p><strong>功能</strong>：</p><ul><li><p>进程：能够完成多任务，如，一台电脑上运行多个qq</p></li><li><p>线程：能够完成多任务，如，一个qq中的多个聊天窗口</p></li></ul></li><li><p><strong>定义的不同</strong>：</p><ul><li><p>进程是系统进行资源分配和调度的一个独立单位</p></li><li><p>线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源，但是它可与同属一个进程和其他线程共享进程所拥有的全部资源</p></li></ul></li><li><p><strong>区别</strong>：</p><ul><li><p>一个程序至少有一个进程，一个进程至少有一个线程</p></li><li><p>线程的划分尺度小于进程，使得多线程程序的并发性高</p></li><li><p>进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率</p></li><li><p>线程不能独立执行，必须依存在进程中</p></li></ul></li><li><p><strong>优缺点</strong>：</p><ul><li>线程执行开销小，但不利于资源的管理和保护；而进程刚好相反</li></ul></li></ul><h2 id="协程" tabindex="-1"><a class="header-anchor" href="#协程" aria-hidden="true">#</a> 协程</h2><h3 id="迭代器" tabindex="-1"><a class="header-anchor" href="#迭代器" aria-hidden="true">#</a> 迭代器</h3><p><strong>定义</strong>：迭代中访问集合元素的一种方式。迭代器是一个可以记住遍历的位置的对象。迭代器对象从集合的第一个元素开始访问，直到所有元素被访问完结束。迭代器只能往前，不会后退</p><p>类中增加<code>__iter__()</code>方法，可以使类的实例对象成为可迭代的对象</p><p>类中增加<code>__iter__()</code>方法和<code>__next__()</code>方法，可以使类的实例对象成为迭代器</p><p><code>iter()</code>：获取可迭代对象的迭代器</p><p><code>next()</code>：获取迭代器的下一个数据</p><p><code>raise StopIteration</code>：抛出异常，终止迭代</p><p><strong>迭代器优点</strong>：占用空间少，存储的是生成数据的方法，而不是数据本身</p><h3 id="生成器" tabindex="-1"><a class="header-anchor" href="#生成器" aria-hidden="true">#</a> 生成器</h3><p><strong>定义</strong>：生成器（generator）是一类特殊的迭代器</p><ul><li><p><strong>创建生成器</strong>：</p><p><em><strong>1&gt;</strong></em> <code>gen = (i for i in range(10))</code></p><p><em><strong>2&gt;</strong></em> 在函数中使用<code>yield</code>，让其变成生成器模板</p></li><li><p><strong>启动生成器</strong>：</p><p><em><strong>1&gt;</strong></em> 使用<code>next(gen)</code>启动生成器：取值到尽头报错</p><p><em><strong>2&gt;</strong></em> 使用<code>gen.send(value)</code>启动生成器：取值到尽头报错，</p><p>传递的value值会赋值给<code>i = yield a</code>中的i，且<code>send</code>一般不放在第一位来启动生成器，如果放在第一位，需要传递<code>None</code>，否则会报错，什么都不写也报错</p></li></ul><h3 id="协程实现多任务" tabindex="-1"><a class="header-anchor" href="#协程实现多任务" aria-hidden="true">#</a> 协程实现多任务</h3><ul><li><p>使用<code>yield</code>实现多任务，需配合<code>next(gen)</code>进行启动</p></li><li><p>使用<code>greenlet</code>实现多任务：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code>gr<span class="token operator">=</span>greenlet<span class="token punctuation">(</span>function<span class="token punctuation">)</span>
gr<span class="token punctuation">.</span>switch<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>使用<code>gevent</code>实现多任务：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code>g<span class="token operator">=</span>gevent<span class="token punctuation">.</span>spawn<span class="token punctuation">(</span>function<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>
g<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><p><code>monkey.patch_all()</code>：打补丁，将程序中用到的耗时操作的代码，换为<code>gevent</code>中自己实现的模块</p><p><code>gevent.joinall([gevent.spawn(函数名, 参数), gevent.spawn(函数名, 参数)])</code></p><h2 id="进程、线程、协程比较" tabindex="-1"><a class="header-anchor" href="#进程、线程、协程比较" aria-hidden="true">#</a> 进程、线程、协程比较</h2><p><em><strong>1&gt;</strong></em> 进程是资源分配的单位</p><p><em><strong>2&gt;</strong></em> 线程是操作系统调度的单位</p><p><em><strong>3&gt;</strong></em> 进程切换需要的资源很大，效率很低</p><p><em><strong>4&gt;</strong></em> 线程切换需要资源一般，效率一般（当然了在不考虑GIL的情况下）</p><p><em><strong>5&gt;</strong></em> 协程切换任务资源很小，效率高</p><p><em><strong>6&gt;</strong></em> 多进程、多线程根据CPU核数不一样可能是并行的，但是协程是在一个线程中，所以是并发的</p>`,56),o=[p];function c(i,l){return a(),s("div",null,o)}const d=n(t,[["render",c],["__file","02_多任务.html.vue"]]);export{d as default};
