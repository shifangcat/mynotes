import{_ as r}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as a,o as i,c as E,a as g,b as n,d as s,e as t,w as l,f as p}from"./app-VKLC1A-x.js";const c={},u=n("p",null,"记录一些大数据面试时可能会被问到的问题",-1),d=n("h1",{id:"大数据面试宝典",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#大数据面试宝典","aria-hidden":"true"},"#"),s(" 大数据面试宝典")],-1),_=n("h2",{id:"基础技能",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#基础技能","aria-hidden":"true"},"#"),s(" 基础技能")],-1),A=p(`<li><p><strong>SQL 语句的执行顺序</strong>：</p><p>①FROM -&gt; ②JOIN -&gt; ③WHERE -&gt; ④GROUP BY -&gt; ⑤HAVING -&gt; ⑥SELECT -&gt; ⑦ORDER BY</p></li><li><p><strong>Oracle 的伪表及伪列</strong>：</p><p>伪表：DUAL</p><p>伪列：ROWID、ROWNUM</p></li><li><p><strong>常用的空值转换函数及区别</strong>：</p><p><strong>NVL</strong>：接受两个参数，如果第一个参数不为空则返回第一个参数，否则返回第二个参数</p><p><strong>NVL2</strong>：接受三个参数，如果第一个参数不为空返回第二个参数，如果第一个参数为空则返回第三个参数</p><p><strong>COALESCE</strong>：接受两个或者多个参数，在多个参数中选择第一个非空值</p></li><li><p><strong>COUNT(1)、COUNT(*)、COUNT(字段)的区别</strong>：</p><p><strong>COUNT(1)</strong>：统计选定的列中的行数，不考虑列中的具体值，通常用于统计行数，而且因为 1 是常量，也会提高执行效率</p><p><strong>COUNT(*)</strong>：统计选定列中的行数，包括 NULL 值，得到的结果跟 COUNT(1) 是一致的，但是因为它需要检查每一行的所有列，效率通常比 COUNT(1) 慢</p><p><strong>COUNT(字段)</strong>：统计指定字段中非 NULL 值的数量</p></li><li><p><strong>关联查询 WHERE 跟 ON 的区别</strong>：</p><p>关联查询条件放在 WHERE 跟 ON 后面，当内连接取交集的时候，没有区别；取外连接的时候，因为 WHERE 是过滤条件，它可以过滤主表的数据，但是 ON 后面接的是关联条件，它不能过滤主表的数据</p></li><li><p><strong>WHERE 跟 HAVING 的区别</strong>：</p><p>WHERE 子句在执行查询之前对表中的行进行过滤，用于对列值进行条件判断，过滤掉不满足条件的行；</p><p>HAVING 子句通常用于对聚合函数的结果进行过滤，例如对总和、平均值、总数等聚合函数的结果进行过滤，过滤掉不满足条件的聚合结果</p></li><li><p><strong>关联查询数据发散怎么办</strong>：</p><p>数据发散一般是在表关联的时候，存在一对多或者多对多导致的，一般是检查表关联的 ON 或者 WHERE 后面的关联条件，进行单表注释分别看 <code>COUNT(1)</code> 统计的行数来定位是关联哪张表时出现的数据发散</p></li><li><p><strong>什么是笛卡尔积</strong>：</p><p>表与表之间时关联条件恒成立或者没写表关联条件的时候就会生成笛卡尔乘积，得到的数据条数是两张表的数据条数的乘积</p></li><li><p><strong>如何实现分页查询</strong>：</p><p>在 Oracle 中可以使用 ROWNUM 伪列，因为 ROWNUM 不能取大于，所以可以在子查询中给 ROWNUM 取别名，然后用别名 BETWEEN AND 去查；在其他数据库如 MySQL 中，可以使用 LIMIT 进行分页查询</p></li><li><p><strong>数据库语言有哪些</strong>：</p><p><strong>数据定义语言（DDL）</strong>：包括 CREATE（创建）命令、ALTER（修改）命令、DROP（删除）命令等</p><p><strong>数据操纵语言（DML）</strong>：包括 INSERT（插入）命令、UPDATE（更新）命令、DELETE（删除）命令等</p><p><strong>数据査询语言（DQL）</strong>：包括基本査询语句、Order By子句、Group By 子句等</p><p><strong>事务控制语言（TCL）</strong>：包括 COMMIT（提交）命令、ROLLBACK（回滾）命令</p><p><strong>数据控制语言（DCL）</strong>：GRANT（授权）命令、REVOKE（撤销）命令</p></li><li><p><strong>连接査询有哪些</strong>：</p><p>连接查询有：内连接（INNER JOIN），外连接（LEFT/RIGHT JOIN），全外连接（FULL JOIN）</p><p>内连接取两表的交集</p><p>外连接取主表的全量结果集</p><p>全外连接取两张表的所有结果集</p></li><li><p><strong>UNION ALL 和 UNION 的区别</strong>：</p><p>两者的作用都是合并结果集，其中 UNION 会去重，UNION ALL 不会去重，UNION ALL 性能更好</p></li><li><p><strong>Oracle 去重方案有哪些</strong>：</p><p>DISTINCT、GROUP BY、ROWID</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">-- 使用 rowid 去重</span>
<span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> EMP_BAK
<span class="token keyword">WHERE</span> ROWID <span class="token operator">NOT</span> <span class="token operator">IN</span> <span class="token punctuation">(</span>
	<span class="token keyword">SELECT</span> <span class="token function">MAX</span><span class="token punctuation">(</span>ROWID<span class="token punctuation">)</span> <span class="token keyword">FROM</span> EMP_BAK
     <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> EMPNO
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>delete、truncate、drop 的区别</strong>：</p><p>delete 是 DML 语句，可以提交可以回滚；truncate 是 DDL 语句， 全量删除，没有提交跟回滚</p><p>在程序块中 truncate 需要使用动态 SQL 去执行，而 delete 可以直接引用</p><p>truncate 是表清空，delete 是通过条件进行删除</p><p>drop 是删除表，连带表结构也给删了，truncate 和 delete 在清空或者删除数据时表结构仍旧保留</p></li><li><p><strong>主键与唯一索引的区别</strong>：</p><p>主键唯一且非空</p><p>唯一索引允许为空，且可以同时存在多行空值</p></li><li><p><strong>列举常用的函数</strong>：</p><p><strong>数学函数</strong>：ABS（绝对值）、ROUND（四舍五入）、FLOOR（向下取整）、CEIL（向下取整）</p><p><strong>字符函数</strong>：SUBSTR（截取）、RELACE（替换）、INSTR（查找字符索引位置）、TRIM（去空格）、LPAD（左填充）</p><p><strong>日期函数</strong>：TRUNC（截取日期）、ADD_MONTHS（增加月）、MONTHS_BETWEEN（计算月份差）、LAST_DAY（月末最后一天）</p></li><li><p><strong>怎么获取上个季度最后一天</strong>：</p><p>TRUNC 截取日期到 Q（季度），然后日期减 1</p></li><li><p><strong>怎么取每门课程最高分的学生姓名</strong>：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>FIRST_VALUE<span class="token punctuation">(</span>姓名<span class="token punctuation">)</span> <span class="token keyword">OVER</span> <span class="token punctuation">(</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> 课程 <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> 成绩 <span class="token keyword">DESC</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p><strong>常用的分析函数（开窗函数）</strong>：</p><p><strong>FIRST_VALUE</strong>：取第一个值</p><p><strong>NTILE</strong>：切片函数</p><p><strong>RATIO_TO_REPORT</strong>：计算占比（计算分摊的时候常用）</p><p><strong>ROW_NUMBER、RANK、DENSE_RANK</strong>：取排名</p><p><strong>LAG、LEAD</strong>：偏移函数</p><p><strong>聚合函数</strong>：SUM() OVER、MAX() OVER、MIN() OVER</p></li><li><p><strong>ROW_NUMBER、RANK、DENSE_RANK的区别</strong>：</p><p>三者都是取排名的分析函数，不同的是，是否考虑并列以及是否空出排名，比如：</p><p><strong>ROW_NUMBER</strong> 取出来的排名是：1、2、3、4，因为不会并列排名，所以对于相同的内容进行排序时会存在一定的随机性，每次排序的结果可能不同</p><p><strong>RANK</strong> 取出来的是：1、2、2、4</p><p><strong>DENSE_RANK</strong> 取出来的是：1、2、2、3</p></li>`,20),m=n("p",null,[n("strong",null,"行列转换怎么转换"),s("：")],-1),k=n("p",null,[n("strong",null,"行转列"),s("：PIVOT、LAG、LEAD、CASE WHEN、DECODE 等")],-1),B=n("p",null,[n("strong",null,"列转行"),s("：UNPIVOT 以及 UNION ALL")],-1),h=p(`<li><p><strong>EXISTS 跟 IN 的区别</strong>：</p><p>EXISTS 走的是表关联，IN 的话是遍历结果集去匹配，所以在数据量大的时候，一般会选择使用 EXISTS，走表关联的话对应计算机的扫描次数要比遍历结果集扫描次数少很多，能提升 SQL 的执行效率</p></li><li><p><strong>一个表中有员工以及领导，找出某个员工所有下属信息</strong>：</p><p>用递归查询，语法是：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> 表
<span class="token keyword">START</span> <span class="token keyword">WITH</span> 姓名 <span class="token operator">=</span> 员工姓名
<span class="token keyword">CONNECT</span> <span class="token keyword">BY</span> PRIOR 员工姓名 <span class="token operator">=</span> 领导姓名<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>查询输出 1-1000</strong>：</p><p>用递归查询，语法是：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token keyword">LEVEL</span> <span class="token keyword">FROM</span> DUAL
<span class="token keyword">CONNECT</span> <span class="token keyword">BY</span> <span class="token keyword">LEVEL</span> <span class="token operator">&lt;=</span> <span class="token number">1000</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>找出哪些人连续登陆多少天</strong>：</p><p>判断某个字段连续，需要把这个字段跟另外一个连续字段（如排名）相减，差值相同，则连续，然后用差值分组计数就是连续的次数，另外一个连续字段基本上都是用 ROW_NUMBER</p></li>`,4),L=n("p",null,[n("strong",null,"Oracle PL/SQL 的循环"),s("：")],-1),N=n("p",null,"FOR 循环、LOOP 循环、WHILE 循环",-1),O=p(`<ul><li><p><strong>FOR 循环</strong>：一种基于计数器的循环结构，在每次迭代时递增计数器的值，直到达到指定的结束条件为止</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">DECLARE</span>
    v_counter NUMBER<span class="token punctuation">;</span>
<span class="token keyword">BEGIN</span>
    <span class="token keyword">FOR</span> v_counter <span class="token operator">IN</span> <span class="token number">1.</span><span class="token number">.10</span> <span class="token keyword">LOOP</span>
        DBMS_OUTPUT<span class="token punctuation">.</span>PUT_LINE<span class="token punctuation">(</span><span class="token string">&#39;Counter: &#39;</span> <span class="token operator">||</span> v_counter<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">END</span> <span class="token keyword">LOOP</span><span class="token punctuation">;</span>
<span class="token keyword">END</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>LOOP 循环</strong>：一种无限循环结构，需要在循环体内部通过条件语句（如 EXIT WHEN）来控制循环的终止条件</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">DECLARE</span>
    v_counter NUMBER :<span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">BEGIN</span>
    <span class="token keyword">LOOP</span>
        DBMS_OUTPUT<span class="token punctuation">.</span>PUT_LINE<span class="token punctuation">(</span><span class="token string">&#39;Counter: &#39;</span> <span class="token operator">||</span> v_counter<span class="token punctuation">)</span><span class="token punctuation">;</span>
        v_counter :<span class="token operator">=</span> v_counter <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">EXIT</span> <span class="token keyword">WHEN</span> v_counter <span class="token operator">&gt;</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">END</span> <span class="token keyword">LOOP</span><span class="token punctuation">;</span>
<span class="token keyword">END</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>WHILE 循环</strong>：基于指定条件的循环结构，在每次迭代之前检查条件是否满足，只有当条件为真时循环继续执行</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">DECLARE</span>
    v_counter NUMBER :<span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">BEGIN</span>
    <span class="token keyword">WHILE</span> v_counter <span class="token operator">&lt;=</span> <span class="token number">10</span> <span class="token keyword">LOOP</span>
        DBMS_OUTPUT<span class="token punctuation">.</span>PUT_LINE<span class="token punctuation">(</span><span class="token string">&#39;Counter: &#39;</span> <span class="token operator">||</span> v_counter<span class="token punctuation">)</span><span class="token punctuation">;</span>
        v_counter :<span class="token operator">=</span> v_counter <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">END</span> <span class="token keyword">LOOP</span><span class="token punctuation">;</span>
<span class="token keyword">END</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul>`,1),v=n("li",null,[n("p",null,[n("strong",null,"局部变量跟全局变量"),s("：")]),n("p",null,"全局变量我们一般定义在 package 的包头，所有存储过程都可以调用，局部变量定义在某个存储过程的程序块当中，只能当前存储过程调用")],-1),R=n("p",null,[n("strong",null,"游标分几种"),s("：")],-1),D=n("p",null,"隐式游标：SELECT INTO",-1),T=n("p",null,"显式游标：CURSOR",-1),I=p("<li><p><strong>游标的使用场景</strong>：</p><p>游标是封装一个结果集的指针，一般在做批量提交以及批量更新的时候经常需要用到游标</p></li><li><p><strong>如何同步很大的源表</strong>：</p><p>一般选择分批次提交，避免 UNDO 表空间不足</p></li><li><p><strong>如何实现分批提交</strong>：</p><p><em><strong>1&gt;</strong></em>：可以定义步长，循环提交</p><p><em><strong>2&gt;</strong></em>：可以使用游标封装结果集，然后限制行输出，进行提交，比如：LIMIT 50000</p><p>PS：分批提交的步长一般是 5 万或者 10 万</p></li><li><p><strong>存储过程一般怎么调用</strong>：</p><p>存储过程的调用一般是通过调度工具，在调度工具里面配置调度命令来调用</p></li>",4),S=n("p",null,[n("strong",null,"存储过程跟自定义函数的区别"),s("：")],-1),b=n("p",null,"存储过程可以调用自定义函数，但是自定义函数一般是不会调用存储过程，最重要的点是，存储过程一般是没有返回值，但是自定义函数肯定有返回值",-1),C=n("p",null,[n("strong",null,"数据的同步方式"),s("：")],-1),U=n("p",null,"增量同步、全量同步",-1),y=n("li",null,[n("p",null,[n("strong",null,"MERGE INTO 常见的报错"),s("：")]),n("p",null,"当增量同步到的对比条件 ON，存在源表多对一目标表的时候，由于多行更新一行，会报错，找不到稳定的行，所以 MERGE INTO 的时候一般都会有对应的主键")],-1),P=n("li",null,[n("p",null,[n("strong",null,"什么时候用增量什么时候用全量"),s("：")]),n("p",null,"一般针对源业务系统的数据量级，数据量大一般选择增量，数据量小一般是全量；或者看具体的业务需求"),n("p",null,"PS：量大量小的标准在 100 万条左右")],-1),F=n("p",null,[n("strong",null,"异常处理怎么处理"),s("：")],-1),w=n("p",null,"一般在程序的结尾会增加异常处理，定义 EXCEPTION WHEN 异常场景 THEN 捕捉对应的异常信息，写入日志表，记录异常的详细信息",-1),M=n("p",null,[n("strong",null,"包、存储过程、自定义函数的区别"),s("：")],-1),f=n("p",null,"包是用来封装自定义函数以及存储过程的",-1),H=n("p",null,"存储过程一般没有返回值，可以调用自定义函数",-1),W=n("p",null,"自定义函数有返回值，一般是不会调用存储过程",-1),q=n("p",null,[n("strong",null,"日志表一般包含哪些字段"),s("：")],-1),x=n("p",null,"步骤名称、开始时间、结束时间、影响行数、状态、备注等",-1),Q=n("p",null,[n("strong",null,"序列的使用"),s("：")],-1),G=n("p",null,"序列可以定义步长，自增或者自减，一般会结合主键去用",-1),V=n("li",null,[n("p",null,[n("strong",null,"视图跟表的区别"),s("：")]),n("p",null,"视图存储的不是数据，而是一段查询逻辑；表存储的是有具体的数据"),n("p",null,"视图的更新限制必须是单表查询，且查询字段是基表的源字段才能被更新，最终更新的是基表的数据")],-1),K=n("p",null,[n("strong",null,"普通视图跟物化视图的区别"),s("：")],-1),X=n("p",null,[n("strong",null,"普通视图"),s("：不存储实际的数据，它只是保存了定义该视图的查询逻辑，基表发生变化时，通过普通视图查询的结果也会立刻发生变化；而且当存储的查询逻辑太复杂时，查询效率也比较慢")],-1),Y=n("p",null,[n("strong",null,"物化视图"),s("：是预先计算并存储了查询语句的结果集的一种视图，当数据发生变化时，需要手动或自动地刷新物化视图以保持数据的最新性；因为保存的是具体的数据，所以查询时效率较高")],-1),J=n("p",null,[n("strong",null,"Oracle 中的正则函数"),s(":")],-1),j=n("p",null,"支持正则表达式的四个函数分别是：REGEXP_LIKE、REGEXP_INSTR、REGEXP_SUBSTR、REGEXP_REPLACE",-1),z=n("li",null,[n("p",null,[n("strong",null,"拉链表的原理"),s("：")]),n("p",null,"拉链表对比源表，新增开始时间、结束时间、以及 FLAG 标志位，拉链表对比源表，有则更新，无则插入")],-1),Z=n("p",null,[n("strong",null,"拉链表的开链跟闭链"),s("：")],-1),$=n("p",null,[n("strong",null,"开链"),s("：开链表示的是数据的当前有效状态。在拉链表中，每条记录通常包含一个开始日期和一个结束日期。对于开链数据，通过 "),n("code",null,"INSERT"),s(" 插入源表最新的数据，结束日期通常设置为一个遥远的未来日期（如 9999-12-31），这表示这条记录是当前有效的，没有结束。当数据发生变化时，系统会创建一条新的记录，这条新记录的开始日期是变化发生的日期，而结束日期仍然是遥远的未来日期，以此来表示新的有效状态")],-1),nn=n("p",null,[n("strong",null,"闭链"),s("：闭链表示的是数据的历史状态。当数据发生变化时，原有的记录会被更新，使用 "),n("code",null,"UPDATE"),s(" 将结束日期设置为变化发生的前一天，这样这条记录就不再表示当前状态，而是成为了历史记录。所有的历史记录（闭链）都可以通过开始日期和结束日期的范围来查询，从而追溯数据的历史变更")],-1),sn=p("<li><p><strong>拉链表的优缺点</strong>：</p></li><li><p><strong>优点</strong>：</p><p><em><strong>1&gt;</strong></em> <strong>节省存储空间</strong>：拉链表通过记录数据变更历史，避免了重复存储相同数据，从而节省了存储空间</p><p><em><strong>2&gt;</strong></em> <strong>易于查询</strong>：通过查询创建时间和更新时间等字段，可以快速定位数据变更历史，便于进行历史数据的追溯和审计</p><p><em><strong>3&gt;</strong></em> <strong>数据完整性</strong>：拉链表能够完整地记录数据的变更过程，为数据分析提供了丰富的历史信息</p><p><em><strong>4&gt;</strong></em> <strong>灵活性</strong>：拉链表支持历史数据的查询，可以根据需要查看任意时间点的数据状态</p></li><li><p><strong>缺点</strong>：</p><p><em><strong>1&gt;</strong></em> <strong>数据冗余</strong>：虽然拉链表节省了存储空间，但为了记录历史状态，它可能会在一定程度上引入数据冗余</p><p><em><strong>2&gt;</strong></em> <strong>数据质量</strong>：如果数据变更频繁，拉链表可能会变得复杂，难以维护，从而影响数据质量</p><p><em><strong>3&gt;</strong></em> <strong>查询性能</strong>：对于需要频繁查询历史数据的场景，拉链表可能会因为数据量大而导致查询性能下降</p><p><em><strong>4&gt;</strong></em> <strong>实现复杂性</strong>：拉链表的实现和维护相对复杂，需要额外的逻辑来处理数据的插入、更新和删除操作</p></li><li><p><strong>查询拉链表最新的一版数据</strong>：</p><p>取 FLAG = 1 的数据，或者失效时间为最大时间的数据</p></li><li><p><strong>查询拉链表在某个时间点的数据</strong>：</p><p>取开始时间小于等于这个时间点，并且结束时间大于等于这个时间点的数据</p></li><li><p><strong>查询拉链表中在某个时间点发生变化的数据</strong>：</p><p>开始时间 = 这个时间点 OR 结束时间 = 这个时间点的数据</p></li><li><p><strong>什么表适合做拉链表</strong>：</p><p>收入流水不适合做成拉链表，因为历史数据不会发生改变。适合做拉链表的一般是一些伪表，比如：客户信息表、员工表、产品定价表等，可以看到客户信息、员工信息或者产品价格是什么时候发生变化的</p></li><li><p><strong>数据库备份怎么做</strong>：</p><p>数据备份分为热备份跟冷备份，热备份是不停机备份，冷备份是停机备份，具体备份操作由运维人员负责</p></li>",8),tn=n("p",null,[n("strong",null,"数仓架构"),s("：")],-1),on=n("p",null,[n("strong",null,"ODS 层"),s("：也叫数据贴源层，主要是对接各来源业务系统，同步以及存储来源数据")],-1),ln=n("p",null,[n("strong",null,"DW 层"),s("：也叫数据仓库层，主要是依据公司的各大业务板块划分多个主题进行存放以及分析取数，针对 ODS 层的源数据进行主题划分，以及筛选整合，做轻粒度汇总")],-1),pn=n("p",null,[n("strong",null,"DM 层"),s("：也就是集市层，主要是对接前端 BI 报表，计算展示层需要展示的指标字段，以及对数据的最终聚合，为前端的BI可视化，提供数据准备")],-1),en=n("h2",{id:"建模",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#建模","aria-hidden":"true"},"#"),s(" 建模")],-1),an=p("<p><strong>范式建模、维度建模</strong>：</p><p><strong>范式建模</strong>：在范式理论上符合 3NF，从流程上看是<em><strong>自上而下</strong></em>的，自上而下指的是数据的流向，即从分散异构的数据源 -&gt; 数据仓库 -&gt; 数据集市，<em><strong>以数据源头为导向</strong></em>，一步步探索获取尽量符合预期的数据，将数据抽取为<em><strong>实体-关系</strong></em>模型</p><p><strong>维度建模</strong>：从流程上看是<em><strong>自下而上</strong></em>的，即从数据集市-&gt; 数据仓库 -&gt; 分散异构的数据源，<em><strong>以最终任务为导向</strong></em>，将数据抽取为<em><strong>事实-维度</strong></em>模型，<em><strong>数据源经ETL转化为事实表和维度表导入数据集市</strong></em>，以星型模型或雪花模型等方式构建维度数据仓库，数据集市是数据仓库中一个逻辑上的主题域</p>",3),rn={href:"https://mp.weixin.qq.com/s/-W4Fh3fDhMJTyj92RuNOaw",target:"_blank",rel:"noopener noreferrer"},En=n("p",null,[n("strong",null,"三范式"),s("：")],-1),gn=n("p",null,[n("strong",null,"第一范式（1NF）"),s("：确保每个表中的每个字段都是原子的，不可再分的。即每个字段不能包含多个值或重复的值")],-1),cn=n("p",null,[n("strong",null,"第二范式（2NF）"),s("：确保每个非主键字段完全依赖于整个主键，而不是依赖于主键的一部分，即消除部分依赖")],-1),un=n("p",null,[n("strong",null,"第三范式（3NF）"),s("：确保每个非主键字段只依赖于主键，而不依赖于其他非主键字段，即消除传递依赖")],-1),dn={href:"https://mp.weixin.qq.com/s/5ANcTuW8z2XZQDGOInORnA",target:"_blank",rel:"noopener noreferrer"},_n=p("<p><strong>星型模型、雪花模型、星座模型</strong>：</p><p><strong>星型模型</strong>：是<em><strong>以事实表为中心，所有的维度表直接连接在事实表上，像星星一样</strong></em></p><p>星形模式的维度建模由一个事实表和一组维表成，且具有以下<strong>特点</strong>：</p><p>a. 维表只和事实表关联，维表之间没有关联</p><p>b. 每个维表主键为单列，且该主键放置在事实表中，作为两边连接的外键</p><p>c. 以事实表为核心，维表围绕核心呈星形分布；星型模型的缺点是数据的存储因为不存在渐变维度，所以可能导致数据的冗余</p><p><strong>雪花模型</strong>：<em><strong>维度表可以拥有其他维度表</strong></em>，虽然这种模型相比星型更规范一些，但是由于这种模型不太容易理解，维护成本比较高，而且性能方面需要关联多层维表，性能也比星型模型要低，所以一般不是很常用</p><p><strong>星座模型</strong>：星座模式是星型模式延伸而来，星型模式是基于一张事实表的，而<strong>星座模式是基于多张事实表的，而且共享维度信息</strong>。前面介绍的两种维度建模方法都是多维表对应单事实表，但在很多时候维度空间内的事实表不止一个，而一个维表也可能被多个事实表用到。<strong>在业务发展后期，绝大部分维度建模都采用的是星座模式</strong></p>",8),An={href:"https://mp.weixin.qq.com/s/h6HnkROzljralUj2aZyNUQ",target:"_blank",rel:"noopener noreferrer"},mn=n("h2",{id:"oracle-优化",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#oracle-优化","aria-hidden":"true"},"#"),s(" Oracle 优化")],-1),kn=n("p",null,[n("strong",null,"索引分类"),s("：")],-1),Bn=n("p",null,"唯一索引、组合索引、位图索引、基于函数的索引",-1),hn=p("<li><p><strong>组合索引场景怎么判断</strong>：</p><p>组合索引，只有第一列或者所有索引列被调用的时候，才会走索引扫描</p><p><strong>好处</strong>：减少开销、覆盖索引、效率高，索引越多，通过索引筛选出的数据越少</p></li><li><p><strong>位图索引的使用场景</strong>：</p><p>位图索引是建立在重复性比较高的列上，如：性别、婚姻状态、学历等</p></li><li><p><strong>索引失效的场景</strong>：</p><p>索引列的逻辑运算，隐式转换，字符函数转化，以及 NOT IN，模糊查询（LIKE &#39;%A&#39; 索引失效，LIKE &#39;A%&#39; 不会导致索引失效），不等值判断，以及空值判断</p></li><li><p><strong>索引失效、索引紊乱怎么办</strong>：</p><p>使用 Hints 强制走索引，在 SELECT 后面加一行注释符 <code>(+index (表名 索引名))</code></p></li><li><p><strong>不走索引扫描的原因</strong>：</p><p>索引失效；数据量太小</p></li><li><p><strong>索引的优缺点</strong>：</p><p><strong>优点</strong>：提升检索效率（增加查询效率）</p><p><strong>缺点</strong>：占用表空间；降低增删改的执行效率；增加了维护成本</p></li>",6),Ln=n("p",null,[n("strong",null,"常用的分区类型"),s("：")],-1),Nn=n("p",null,"范围分区、列表分区、哈希分区、组合分区",-1),On=n("p",null,[n("strong",null,"执行计划"),s("：")],-1),vn=n("p",null,[s("用 "),n("code",null,"EXPLAIN PLAN FOR SQL语句"),s(" 看对应的执行计划，主要看：")],-1),Rn=n("p",null,"扫描方式：全表扫描、索引扫描",-1),Dn=n("p",null,"耗费：耗费越高，性能越差",-1),Tn=p("<p><strong>SQL 优化</strong>：</p><p><em><strong>1&gt;</strong></em> 创建合适的索引，使用中避免索引失效（使用逻辑运算符、隐式转换、函数和模糊查询等）</p><p><em><strong>2&gt;</strong></em> 大表先过滤再关联，先过滤再分组等</p><p><em><strong>3&gt;</strong></em> 避免使用 order by、distinct、union all 等</p><p><em><strong>4&gt;</strong></em> 对于大数据量使用 exist、not exist 代替 in 和 not in</p><p><em><strong>5&gt;</strong></em> 合理使用 hint 提示，强制走索引等</p><p><em><strong>6&gt;</strong></em> 替换原表，在能提供相同数据的情况下，使用效率更高的表</p><p><em><strong>7&gt;</strong></em> 进行语句拆分，看能否并行执行，避免串行执行浪费等待时间</p><p><em><strong>8&gt;</strong></em> 用 in 或者 not in 的可以考虑使用 join 来实现（类似 exist 走表关联）</p>",9),In={href:"https://zhuanlan.zhihu.com/p/265852739",target:"_blank",rel:"noopener noreferrer"},Sn=n("h2",{id:"大数据相关",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#大数据相关","aria-hidden":"true"},"#"),s(" 大数据相关")],-1),bn=n("p",null,[n("strong",null,"Hadoop 的三大核心组件"),s("：")],-1),Cn=n("p",null,[n("strong",null,"MapReduce"),s("：计算引擎")],-1),Un=n("p",null,[n("strong",null,"HDFS"),s("：分布式的文件存储系统")],-1),yn=n("p",null,[n("strong",null,"Yarn"),s("：处理资源调度")],-1),Pn=p("<li><p><strong>MapReduce 的处理过程</strong>：</p><ul><li><p><strong>Map 阶段</strong>：</p><p><em><strong>1&gt;</strong></em> <strong>分片（Splitting）</strong>：输入数据集被分成若干个数据块，每个数据块称为一个输入分片（Input Split）</p><p><em><strong>2&gt;</strong></em> <strong>映射（Mapping）</strong>：每个输入分片由 Map 任务处理。在映射阶段，每个 Map 任务将输入数据转换为键值对（key-value pairs）</p><p><em><strong>3&gt;</strong></em> <strong>中间结果输出（Intermediate Output）</strong>：Map 任务产生的键值对被缓存在内存中，并根据键进行排序后，输出到本地磁盘上的临时文件中</p></li><li><p><strong>Reduce 阶段</strong>：</p><p><em><strong>1&gt;</strong></em> <strong>合并（Shuffling）</strong>：在 Shuffle 阶段，框架将相同 key 的键值对从不同 Map 任务输出的中间结果汇总到同一个 Reduce 任务上</p><p><em><strong>2&gt;</strong></em> <strong>排序（Sorting）</strong>：Reduce 任务对接收到的键值对进行排序</p><p><em><strong>3&gt;</strong></em> <strong>归约（Reducing）</strong>：Reduce 任务对每组具有相同 key 的键值对执行归约操作，生成最终的输出结果</p></li><li><p><strong>MapReduce 处理过程的一般流程</strong>：</p><p><em><strong>1&gt;</strong></em> 输入数据被分片并由多个 Map 任务并行处理，每个 Map 任务生成中间键值对</p><p><em><strong>2&gt;</strong></em> 中间结果根据键进行分组和排序，然后传递给 Reduce 任务</p><p><em><strong>3&gt;</strong></em> Reduce 任务对相同 key 的键值对执行归约操作，生成最终的输出结果</p></li></ul></li><li><p><strong>Hive 跟 Oracle 的区别</strong>：</p><p>Hive 主要是处理大数据的，搭建在 Hadoop 集群环境下，使用的引擎是 MapReduce，因此执行延迟相对较高，另外数据的存储是在 HDFS 上的，另外就是跟 Oracle 这一块语法上大同小异，比如：不能直接使用 delete 以及 update 等</p></li><li><p><strong>内部表跟外部表的区别</strong>：</p><p>内表被删除了，元数据以及数据文件都被删了，外表在删除的时候，HDFS 上的数据文件不会被删</p></li><li><p><strong>Hive 的分区跟分桶的区别</strong>：</p><p>分区是按照虚拟的字段进行有规则分区，分桶的话是按照数据行的哈希值进行取模分桶，对应的每个桶内的数据量比较均匀</p></li><li><p><strong>Hive 的数据文件种类</strong>：</p><p>有 5 种：ORC、Parquet、Avro、TextFile、SequenceFile</p><p>ORC 和 Parquet 使用较多，两种格式压缩率较高，能有效节省空间，同时支持多种数据结构，也有较高的查询性能；缺点是写入速度较慢，不适合频繁更新的场景</p></li><li><p><strong>数据倾斜的原因和处理方案</strong>：</p><ul><li><p><strong>原因</strong>：数据存储或生成的过程中，有些数据集中在几个值上，导致数据分布不均匀，从而产生数据倾斜</p></li><li><p><strong>处理方案</strong>：</p><p><em><strong>1&gt;</strong></em> 重新设计导致数据倾斜的键，引入随机化技术，将其可以均匀分布到不同节点上</p><p><em><strong>2&gt;</strong></em> 在进行连接操作时，选择合适的连接键，避免使用分布不均匀的键导致数据倾斜</p><p><em><strong>3&gt;</strong></em> 对数据进行更细粒度的分区，使用数据分布更加均匀，降低数据倾斜发生的可能性</p><p><em><strong>4&gt;</strong></em> 对于数据倾斜的任务，可以动态调整任务的并行度，将负载均衡地分配到不同的节点上</p></li></ul></li><li><p><strong>锁和死锁</strong>：</p><p><strong>锁</strong>是某个用户在更新、修改数据时，锁定当前表或记录，不允许其它用户修改</p><p><strong>死锁</strong>是两个会话，持有对方想要资源，因争夺资源而造成的互相等待现象，比如：A 用户执行 DML 语句未提交，B 用户针对当前事务做其它操作时，就有可能导致死锁</p></li><li><p><strong>如何处理死锁</strong>：</p><p>通过查询系统锁的对象表查找对应的 sid、serial# 字段，然后 kill 掉对应的任务进程</p></li>",8);function Fn(wn,Mn){const o=a("RouterLink"),e=a("ExternalLinkIcon");return i(),E("div",null,[u,g(" more "),d,_,n("ul",null,[A,n("li",null,[m,k,B,n("p",null,[s("参考资料："),t(o,{to:"/docs/%E5%A4%A7%E6%95%B0%E6%8D%AE/01_Oracle%E5%9F%BA%E7%A1%80/12_%E8%A1%8C%E5%88%97%E8%BD%AC%E6%8D%A2.html"},{default:l(()=>[s("行列转换")]),_:1})])]),h,n("li",null,[L,N,n("p",null,[s("参考资料："),t(o,{to:"/docs/%E5%A4%A7%E6%95%B0%E6%8D%AE/02_PLSQL%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/03_%E5%BE%AA%E7%8E%AF.html"},{default:l(()=>[s("循环")]),_:1})]),O]),v,n("li",null,[R,D,T,n("p",null,[s("参考资料："),t(o,{to:"/docs/%E5%A4%A7%E6%95%B0%E6%8D%AE/02_PLSQL%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/08_%E6%B8%B8%E6%A0%87.html"},{default:l(()=>[s("游标")]),_:1})])]),I,n("li",null,[S,b,n("p",null,[s("参考资料："),t(o,{to:"/docs/%E5%A4%A7%E6%95%B0%E6%8D%AE/02_PLSQL%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/04_%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0.html"},{default:l(()=>[s("自定义函数")]),_:1}),s("、"),t(o,{to:"/docs/%E5%A4%A7%E6%95%B0%E6%8D%AE/02_PLSQL%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/06_%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B.html"},{default:l(()=>[s("存储过程")]),_:1})])]),n("li",null,[C,U,n("p",null,[s("参考资料："),t(o,{to:"/docs/%E5%A4%A7%E6%95%B0%E6%8D%AE/02_PLSQL%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/12_%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5.html"},{default:l(()=>[s("数据同步")]),_:1})])]),y,P,n("li",null,[F,w,n("p",null,[s("参考资料："),t(o,{to:"/blog/..docs/%E5%A4%A7%E6%95%B0%E6%8D%AE/02_PLSQL%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/05_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html"},{default:l(()=>[s("异常处理")]),_:1})])]),n("li",null,[M,f,H,W,n("p",null,[s("参考资料："),t(o,{to:"/docs/%E5%A4%A7%E6%95%B0%E6%8D%AE/02_PLSQL%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/13_%E5%8C%85.html"},{default:l(()=>[s("包")]),_:1}),s("、"),t(o,{to:"/docs/%E5%A4%A7%E6%95%B0%E6%8D%AE/02_PLSQL%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/06_%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B.html"},{default:l(()=>[s("存储过程")]),_:1}),s("、"),t(o,{to:"/docs/%E5%A4%A7%E6%95%B0%E6%8D%AE/02_PLSQL%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/04_%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0.html"},{default:l(()=>[s("自定义函数")]),_:1})])]),n("li",null,[q,x,n("p",null,[s("参考资料："),t(o,{to:"/docs/%E5%A4%A7%E6%95%B0%E6%8D%AE/02_PLSQL%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/07_%E6%97%A5%E5%BF%97%E8%A1%A8.html"},{default:l(()=>[s("日志表")]),_:1})])]),n("li",null,[Q,G,n("p",null,[s("参考资料："),t(o,{to:"/docs/%E5%A4%A7%E6%95%B0%E6%8D%AE/02_PLSQL%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/07_%E6%97%A5%E5%BF%97%E8%A1%A8.html#%E5%BA%8F%E5%88%97-sequence"},{default:l(()=>[s("序列")]),_:1})])]),V,n("li",null,[K,X,Y,n("p",null,[s("参考资料："),t(o,{to:"/docs/%E5%A4%A7%E6%95%B0%E6%8D%AE/02_PLSQL%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/10_%E8%A7%86%E5%9B%BE.html"},{default:l(()=>[s("视图")]),_:1})])]),n("li",null,[J,j,n("p",null,[s("参考资料："),t(o,{to:"/docs/%E5%A4%A7%E6%95%B0%E6%8D%AE/02_PLSQL%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/11_%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html"},{default:l(()=>[s("正则表达式")]),_:1})])]),z,n("li",null,[Z,$,nn,n("p",null,[s("参考资料："),t(o,{to:"/docs/%E5%A4%A7%E6%95%B0%E6%8D%AE/02_PLSQL%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/16_%E6%8B%89%E9%93%BE%E8%A1%A8.html"},{default:l(()=>[s("拉链表")]),_:1})])]),sn,n("li",null,[tn,on,ln,pn,n("p",null,[s("参考资料："),t(o,{to:"/docs/%E5%A4%A7%E6%95%B0%E6%8D%AE/03_%E9%A1%B9%E7%9B%AE%E8%AF%BE%E7%A8%8B/11_%E6%95%B0%E6%8D%AE%E5%88%86%E5%B1%82.html"},{default:l(()=>[s("数据分层")]),_:1})])])]),en,n("ul",null,[n("li",null,[an,n("p",null,[s("参考资料："),n("a",rn,[s("通俗易懂数仓建模—Inmon范式建模与Kimball维度建模"),t(e)])])]),n("li",null,[En,gn,cn,un,n("p",null,[s("参考资料："),n("a",dn,[s("数据库三范式！三范式！三范式！"),t(e)])])]),n("li",null,[_n,n("p",null,[s("参考资料："),n("a",An,[s("万字详解整个数据仓库建设体系"),t(e)])])])]),mn,n("ul",null,[n("li",null,[kn,Bn,n("p",null,[s("参考资料："),t(o,{to:"/docs/%E5%A4%A7%E6%95%B0%E6%8D%AE/01_Oracle%E5%9F%BA%E7%A1%80/15_%E7%B4%A2%E5%BC%95.html"},{default:l(()=>[s("索引")]),_:1})])]),hn,n("li",null,[Ln,Nn,n("p",null,[s("参考资料："),t(o,{to:"/docs/%E5%A4%A7%E6%95%B0%E6%8D%AE/01_Oracle%E5%9F%BA%E7%A1%80/14_%E5%88%86%E5%8C%BA%E8%A1%A8.html"},{default:l(()=>[s("分区表")]),_:1})])]),n("li",null,[On,vn,Rn,n("p",null,[s("关联机制：嵌套循环、合并排序、散列连接（参考资料："),t(o,{to:"/docs/%E5%A4%A7%E6%95%B0%E6%8D%AE/02_PLSQL%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/18_%E5%85%B3%E8%81%94%E6%9C%BA%E5%88%B6_HINT%E6%8F%90%E7%A4%BA_%E9%AB%98%E6%B0%B4%E4%BD%8D%E7%BA%BF.html#%E5%85%B3%E8%81%94%E6%9C%BA%E5%88%B6"},{default:l(()=>[s("关联机制")]),_:1}),s("）")]),Dn]),n("li",null,[Tn,n("p",null,[s("参考资料："),n("a",In,[s("SQL 优化"),t(e)])])])]),Sn,n("ul",null,[n("li",null,[bn,Cn,Un,yn,n("p",null,[s("参考资料："),t(o,{to:"/docs/%E5%A4%A7%E6%95%B0%E6%8D%AE/03_%E9%A1%B9%E7%9B%AE%E8%AF%BE%E7%A8%8B/03_Hadoop.html"},{default:l(()=>[s("Hadoop")]),_:1})])]),Pn])])}const Wn=r(c,[["render",Fn],["__file","大数据面试宝典.html.vue"]]);export{Wn as default};
