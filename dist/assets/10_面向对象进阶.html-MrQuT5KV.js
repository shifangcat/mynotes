import{_ as n}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as s,c as a,f as t}from"./app-VKLC1A-x.js";const e={},p=t(`<h1 id="面向对象进阶" tabindex="-1"><a class="header-anchor" href="#面向对象进阶" aria-hidden="true">#</a> 面向对象进阶</h1><h2 id="static" tabindex="-1"><a class="header-anchor" href="#static" aria-hidden="true">#</a> static</h2><p><code>static</code> 表示静态，是 Java 中的一个修饰符，可以修饰成员方法和成员变量</p><p>被 <code>static</code> 修饰的成员变量，叫做<strong>静态变量</strong></p><p><strong>特点</strong>：被该类所有对象共享</p><p><strong>调用方式</strong>：</p><p><code>类名.静态变量名</code>（推荐）</p><p><code>对象名.静态变量名</code></p><p>被 <code>static</code> 修饰的成员方法，叫做<strong>静态方法</strong></p><p><strong>特点</strong>：多用在测试类和工具类中，Javabean 类中很少使用</p><p><strong>调用方式</strong>：</p><p><code>类名.静态方法名</code>（推荐）</p><p><code>对象名.静态方法名</code></p><p><strong>static 注意事项</strong>：</p><p><em><strong>1&gt;</strong></em> 静态方法中没有 <code>this</code> 关键字</p><p><em><strong>2&gt;</strong></em> 静态方法只能访问静态变量和静态方法</p><p><em><strong>3&gt;</strong></em> 非静态方法可以访问所有变量和方法，包括静态和非静态的变量和方法</p><h2 id="工具类" tabindex="-1"><a class="header-anchor" href="#工具类" aria-hidden="true">#</a> 工具类</h2><p><strong>Javabean 类</strong>：用来描述一类事物的类，如：Student、Cat等</p><p><strong>测试类</strong>：用来检查其他类是否书写正确，带有 <code>main</code> 方法的类，是程序的主入口</p><p><strong>工具类</strong>：不用来描述一类事物，而是帮助做一些事情的类</p><p><strong>工具类定义注意点</strong>：</p><p><em><strong>1&gt;</strong></em> 类名见名知意，如：<code>ArrUtil</code></p><p><em><strong>2&gt;</strong></em> 私有化构造方法，如：<code>private ArrUtil(){}</code></p><p><em><strong>3&gt;</strong></em> 方法定义为静态方法</p><h2 id="继承" tabindex="-1"><a class="header-anchor" href="#继承" aria-hidden="true">#</a> 继承</h2><p>使用 <code>extends</code> 关键字可以在 Java 中建立类与类之间的继承关系，如：</p><p><code>public class Student extends Person {}</code></p><p><code>Student</code> 称为子类（派生类），<code>Person</code> 称为父类（基类或超类）</p><p><strong>继承的好处</strong>：</p><p><em><strong>1&gt;</strong></em> 可以将多个子类中重复的代码抽取到父类中，提高代码的复用性</p><p><em><strong>2&gt;</strong></em> 子类可以在父类的基础上增加其他功能，使用子类更强大</p><p><strong>继承的特点</strong>：</p><p><em><strong>1&gt;</strong></em> Java 只支持单继承，不支持多继承，但支持多层继承</p><p><em><strong>2&gt;</strong></em> 每一个类都直接或间接地继承于 <code>Object</code> 类，即 <code>Object</code> 类是 Java 中的顶级父类</p><p><strong>子类可以从父类继承的内容</strong>：</p><table><thead><tr><th style="text-align:left;"><strong>内容</strong></th><th style="text-align:left;"><strong>非私有</strong></th><th style="text-align:left;"><strong>私有</strong></th></tr></thead><tbody><tr><td style="text-align:left;">构造方法</td><td style="text-align:left;">不能继承</td><td style="text-align:left;">不能继承</td></tr><tr><td style="text-align:left;">成员变量</td><td style="text-align:left;">可以继承和使用</td><td style="text-align:left;">可以继承，不能使用</td></tr><tr><td style="text-align:left;">成员方法</td><td style="text-align:left;">可以继承</td><td style="text-align:left;">不能继承</td></tr></tbody></table><p><em><strong>注</strong></em>：虚方法表：非 <code>private</code> 修饰且非 <code>static</code> 修饰和非 <code>final</code> 修饰的方法会放入虚方法表中</p><h3 id="继承中元素访问的特点" tabindex="-1"><a class="header-anchor" href="#继承中元素访问的特点" aria-hidden="true">#</a> 继承中元素访问的特点</h3><p><em><strong>1&gt;</strong></em> <strong>成员变量的访问特点</strong>：就近原则，使用 <code>this</code> 直接调用本类，使用 <code>super</code> 直接调用父类</p><p><em><strong>2&gt;</strong></em> <strong>成员方法的访问特点</strong>：就近原则，使用 <code>super</code> 直接调用父类</p><p><em><strong>3&gt;</strong></em> <strong>构造方法的访问特点</strong>：</p><ul><li>父类中的构造方法不会被子类继承</li><li>子类中所有的构造方法默认先访问父类中的无参构造，再执行自己。因为子类在初始化的时候可能会用到父类中的数据，如果父类没有完成初始化，子类将无法使用父类的数据，所以子类在初始化之前一定要调用父类的构造方法来完成父类数据空间的初始化</li><li>子类所有构造方法的第一行默认都是：<code>super()</code>，不写也存在，且必须在第一行</li><li>如果想调用父类的有参构造，则必须要手动写 <code>super(参数)</code> 进行调用</li></ul><h3 id="方法重写" tabindex="-1"><a class="header-anchor" href="#方法重写" aria-hidden="true">#</a> 方法重写</h3><p>当父类的方法不能满足子类的需求时，需要进行方法重写</p><p>同样，在继承体系中，子类出现了和父类中一模一样的方法声明时，就称子类这个方法是重写的方法</p><p>方法重写的<strong>本质</strong>：覆盖虚方法表中的方法</p><p><strong>@Override 重写注解</strong>：</p><p><em><strong>1&gt;</strong></em> <code>@Override</code> 是放在重写后的方法上面，校验子类重写时语法是否正确</p><p><em><strong>2&gt;</strong></em> 加上注解后如果有红包波浪线，表示语法存在错误</p><p><em><strong>3&gt;</strong></em> 建议重写方法都加上 <code>@Override</code> 注解，保证代码安全正确</p><p><strong>重写方法注意点</strong>：</p><p><em><strong>1&gt;</strong></em> 重写方法的名称、形参列表必须和父类中保持一致</p><p><em><strong>2&gt;</strong></em> 子类重写父类方法时，访问权限子类必须大于等于父类（<code>public</code> &gt; <code>protected</code> &gt; 空着不写）</p><p><em><strong>3&gt;</strong></em> 子类重写父类方法时，返回值类型子类必须小于等于父类</p><p><em><strong>4&gt;</strong></em> 建议：重写的方法尽量和父类保持一致</p><p><em><strong>5&gt;</strong></em> 只有被添加到虚方法表中的方法才能被重写</p><h3 id="this、super" tabindex="-1"><a class="header-anchor" href="#this、super" aria-hidden="true">#</a> this、super</h3><p><code>this</code>：理解为一个变量，表示当前方法调用者的地址值</p><p><code>super</code>：代表父类存储空间</p><table><thead><tr><th style="text-align:left;"><strong>关键字</strong></th><th style="text-align:left;"><strong>访问成员变量</strong></th><th style="text-align:left;"><strong>访问成员方法</strong></th><th style="text-align:left;"><strong>访问构造方法</strong></th></tr></thead><tbody><tr><td style="text-align:left;">this</td><td style="text-align:left;"><code>this.成员变量</code><br>访问本类成员变量</td><td style="text-align:left;"><code>this.成员方法(...)</code><br>访问本类成员方法</td><td style="text-align:left;"><code>this(...)</code><br>访问本类构造方法</td></tr><tr><td style="text-align:left;">super</td><td style="text-align:left;"><code>super.成员变量</code><br>访问父类成员变量</td><td style="text-align:left;"><code>super.成员方法(...)</code><br>访问父类成员方法</td><td style="text-align:left;"><code>super(...)</code><br>访问父类构造方法</td></tr></tbody></table><h2 id="多态" tabindex="-1"><a class="header-anchor" href="#多态" aria-hidden="true">#</a> 多态</h2><p>多态：同类型的对象，表现出的不同形态</p><p>表现形式：<code>父类类型 对象名称 = 子类对象;</code></p><p>多态的好处：使用父类类型作为参数，可以接收所有子类对象</p><p><strong>多态的前提</strong>：</p><p><em><strong>1&gt;</strong></em> 有继承关系</p><p><em><strong>2&gt;</strong></em> 有父类引用指向子类对象</p><p><em><strong>3&gt;</strong></em> 有方法重写</p><h3 id="多态调用成员的特点" tabindex="-1"><a class="header-anchor" href="#多态调用成员的特点" aria-hidden="true">#</a> 多态调用成员的特点</h3><p>成员变量的调用：编译看左边，运行也看左边</p><p>成员方法的调用：编译看左边，运行看右边</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">// 创建对象（多态的方式）</span>
		<span class="token class-name">Animal</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token comment">// 调用成员变量：编译看左边，运行也看左边</span>
		<span class="token comment">// 编译看左边：javac 编译代码的时候，会看左边的父类中有没有这个变量，如果有，编译成功，如果没有则编译失败</span>
		<span class="token comment">// 运行也看左边：Java 运行代码的时候，实际获取的值就是左边父类中成员变量的值</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 动物</span>

		<span class="token comment">// 调用成员方法：编译看左边，运行看右边</span>
		<span class="token comment">// 编译看左边：javac 编译代码的时候，会看左边的父类中有没有这个方法，如果有，编译成功，如果没有则编译失败</span>
		<span class="token comment">// 运行看右边：Java 运行代码的时候，实际上运行的是子类中的方法</span>
		a<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Dog -- show 方法</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 父类</span>
<span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
	<span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token string">&quot;动物&quot;</span><span class="token punctuation">;</span>

	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Animal -- show 方法&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 子类</span>
<span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
	<span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token string">&quot;狗&quot;</span><span class="token punctuation">;</span>

	<span class="token annotation punctuation">@Override</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Dog -- show 方法&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="多态的优势" tabindex="-1"><a class="header-anchor" href="#多态的优势" aria-hidden="true">#</a> 多态的优势</h3><p><em><strong>1&gt;</strong></em> 在多态形式下，右边对象可以实现解耦合，便于扩展和维护</p><p><em><strong>2&gt;</strong></em> 定义方法时，使用父类型作为参数，可以接收所有子类对象，体现多态的扩展性与便利</p><h3 id="多态的弊端" tabindex="-1"><a class="header-anchor" href="#多态的弊端" aria-hidden="true">#</a> 多态的弊端</h3><p>不能使用子类的特有功能</p><p><strong>解决办法</strong>：使用强制类型转换，将父类类型转换成子类类型</p><p><strong>注意点</strong>：转换类型与真实类型不一致时会报错，可以使用 <code>instanceof</code> 关键字进行判断</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">// 使用多态的方式创建对象</span>
		<span class="token class-name">Animal</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		a<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 狗在啃骨头</span>

		<span class="token comment">// 多态的弊端：不能调用子类特有的方法</span>
		<span class="token comment">// a.lookHome();</span>

		<span class="token comment">// 解决方法：类型转换</span>
		<span class="token comment">// Dog d = (Dog) a;</span>
		<span class="token comment">// d.lookHome(); // 狗在看家</span>

		<span class="token comment">// 使用 instanceof 关键字进行转换判断</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token keyword">instanceof</span> <span class="token class-name">Dog</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token class-name">Dog</span> d <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Dog</span><span class="token punctuation">)</span> a<span class="token punctuation">;</span>
			d<span class="token punctuation">.</span><span class="token function">lookHome</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token keyword">instanceof</span> <span class="token class-name">Cat</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token class-name">Cat</span> c <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Cat</span><span class="token punctuation">)</span> a<span class="token punctuation">;</span>
			c<span class="token punctuation">.</span><span class="token function">catchMouse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
			<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;没有这个类型，转换失败&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 父类</span>
<span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;动物在吃东西&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 子类一</span>
<span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
	<span class="token annotation punctuation">@Override</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;狗在啃骨头&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lookHome</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;狗在看家&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 子类二</span>
<span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
	<span class="token annotation punctuation">@Override</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;猫在吃鱼&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">catchMouse</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;猫在抓老鼠&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="包" tabindex="-1"><a class="header-anchor" href="#包" aria-hidden="true">#</a> 包</h2><p>包就是文件夹，用来管理各种不同功能的 Java 类，方便代码维护</p><p><strong>包名规则</strong>：公司域名反写+包的作用，需要全部使用英文小写，见名知意，如：<code>com.baidu.array</code></p><p>包名+类名又被称为<em><strong>全类名</strong></em>或者<em><strong>全限定名</strong></em>，如：<code>com.baidu.array.Student</code></p><p><strong>导包的规则</strong>：</p><p><em><strong>1&gt;</strong></em> 使用同一个包中的类时，不需要导包</p><p><em><strong>2&gt;</strong></em> 使用 <code>java.lang</code> 包中的类时，不需要导包</p><p><em><strong>3&gt;</strong></em> 其他情况都需要导包</p><p><em><strong>4&gt;</strong></em> 如果同时使用两个包中的同名类，需要使用全类名</p><h2 id="final" tabindex="-1"><a class="header-anchor" href="#final" aria-hidden="true">#</a> final</h2><p>final：最终的，不可被改变的，可以用于修饰方法、类和变量</p><table><thead><tr><th style="text-align:left;"><strong>元素</strong></th><th style="text-align:left;"><strong>final 修饰说明</strong></th></tr></thead><tbody><tr><td style="text-align:left;">方法</td><td style="text-align:left;">表明该方法是最终方法，不能被重写</td></tr><tr><td style="text-align:left;">类</td><td style="text-align:left;">表明该类是最终类，不能被继承</td></tr><tr><td style="text-align:left;">变量</td><td style="text-align:left;">叫做常量，只能被赋值一次</td></tr></tbody></table><h3 id="常量" tabindex="-1"><a class="header-anchor" href="#常量" aria-hidden="true">#</a> 常量</h3><p>实际开发中，常量一般作为系统的配置信息，方便维护，提高可读性</p><p><strong>常量命名规范</strong>：</p><p>一个单词：全部大写</p><p>多个单词：全部大写，单词之间用 <code>_</code> 隔开</p><p><strong>常量的注意点</strong>：</p><p><code>final</code> 修饰的变量是基本数据类型时，变量存储的<strong>数据值</strong>不能发生变化</p><p><code>final</code> 修饰的变量是引用数据类型时，变量存储的<strong>地址值</strong>不能发生变化，对象内部的数据可以改变</p><h2 id="权限修饰符" tabindex="-1"><a class="header-anchor" href="#权限修饰符" aria-hidden="true">#</a> 权限修饰符</h2><p><strong>权限修饰符</strong>：是用来控制一个成员能够被访问的范围的，可以修饰成员变量、方法、构造方法、内部类</p><p><strong>权限修饰符的分类</strong>：</p><p>有四种，使用范围从小到大：<code>private</code> &lt; 空着不写（缺省/默认）&lt; <code>protected</code> &lt; <code>public</code></p><table><thead><tr><th style="text-align:left;"><strong>修饰符</strong></th><th style="text-align:left;"><strong>同一个类中</strong></th><th style="text-align:left;"><strong>同一个包中其他类</strong></th><th style="text-align:left;"><strong>不同包下的子类</strong></th><th style="text-align:left;"><strong>不同包下的无关类</strong></th></tr></thead><tbody><tr><td style="text-align:left;">private</td><td style="text-align:left;">√</td><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">空着不写</td><td style="text-align:left;">√</td><td style="text-align:left;">√</td><td style="text-align:left;"></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">protected</td><td style="text-align:left;">√</td><td style="text-align:left;">√</td><td style="text-align:left;">√</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">public</td><td style="text-align:left;">√</td><td style="text-align:left;">√</td><td style="text-align:left;">√</td><td style="text-align:left;">√</td></tr></tbody></table><p><strong>权限修饰符的使用规则</strong>：</p><p><em><strong>1&gt;</strong></em> 实际开发中，一般只用 <code>private</code> 和 <code>public</code>，成员变量私有，方法公开</p><p><em><strong>2&gt;</strong></em> 特例：如果方法中的代码是抽取其他方法中的共性代码，这个方法一般也私有</p><h2 id="代码块" tabindex="-1"><a class="header-anchor" href="#代码块" aria-hidden="true">#</a> 代码块</h2><p>代码块分为局部代码块、构造代码块、静态代码块</p><h3 id="局部代码块" tabindex="-1"><a class="header-anchor" href="#局部代码块" aria-hidden="true">#</a> 局部代码块</h3><p>局部代码块常用于清除临时变量，提前结束变量的生命周期，节约内存</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CodeBlockDemo01</span> <span class="token punctuation">{</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 局部代码块</span>
		<span class="token punctuation">{</span>
			<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span> <span class="token comment">// 当代码执行到这里时，变量 a 就会从内存中消失，所以下面的代码会报错</span>
		<span class="token comment">// System.out.println(a);</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="构造代码块" tabindex="-1"><a class="header-anchor" href="#构造代码块" aria-hidden="true">#</a> 构造代码块</h3><p>可以将构造方法中重复的代码抽取出来放在构造方法上面，形成构造代码块</p><p>构造代码块会在所有的构造方法执行之前执行，每次创建对象时都会被调用</p><h3 id="静态代码块" tabindex="-1"><a class="header-anchor" href="#静态代码块" aria-hidden="true">#</a> 静态代码块</h3><p><strong>格式</strong>：<code>static {}</code></p><p><strong>特点</strong>：需要使用 <code>static</code> 关键字修饰，随着类的加载而被执行，自动触发，只执行一次</p><p><strong>使用场景</strong>：在类被加载的时候，做一些数据的初始化</p><h2 id="抽象类" tabindex="-1"><a class="header-anchor" href="#抽象类" aria-hidden="true">#</a> 抽象类</h2><p><strong>抽象类</strong>：如果一个<em><strong>类中存在抽象方法</strong></em>，那么该类就必须声明为抽象类</p><p><strong>抽象方法</strong>：将<em><strong>共性的方法</strong></em>抽取到父类之后，由于每一个子类执行的内容是不一样的，所以在父类中不能确定<em><strong>具体的方法体</strong></em>，该方法就可以定义为抽象方法</p><p><strong>抽象类定义格式</strong>：<code>public abstract class 类名{}</code></p><p><strong>抽象方法定义格式</strong>：<code>public abstract 返回值类型 方法名(参数);</code>，没有方法体</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 抽象类</span>
<span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
	<span class="token comment">// 抽象方法</span>
	<span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">work</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>抽象类和抽象方法注意事项</strong>：</p><p><em><strong>1&gt;</strong></em> 抽象类不能实例化（创建对象）</p><p><em><strong>2&gt;</strong></em> 抽象类中不一定有抽象方法，但有抽象方法的类一定是抽象类</p><p><em><strong>3&gt;</strong></em> 抽象类中可以有构造方法</p><p><em><strong>4&gt;</strong></em> 抽象类的子类要么重写抽象类中的所有抽象方法，要么本身也是一个抽象类</p>`,132),o=[p];function c(l,i){return s(),a("div",null,o)}const u=n(e,[["render",c],["__file","10_面向对象进阶.html.vue"]]);export{u as default};
